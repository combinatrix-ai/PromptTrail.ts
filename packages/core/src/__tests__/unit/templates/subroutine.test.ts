import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createSession } from '../../../session';
import { createGenerateOptions } from '../../../generate_options';
import { createContext } from '../../../context';
import { generateText } from '../../../generate';
import { Source } from '../../../content_source';
import {
  Subroutine,
  Sequence,
  Loop,
  System,
  User,
  Assistant,
} from '../../../templates';
import { TemplateFactory } from '../../../templates/factory';
import type { ISession, Session } from '../../../types';
import type { Context } from '../../../context';

// Mock the generate module
vi.mock('../../../generate', () => ({
  generateText: vi.fn(),
}));

describe('SubroutineTemplate', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Set up default mock for generateText
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'Mock response',
      metadata: createContext(),
    });
  });

  // Original functionality tests

  it('should execute a simple subroutine and merge results by default', async () => {
    // Create a subroutine template with a simple sequence
    const subroutine = new Subroutine(
      new Sequence()
        .addSystem('You are a helpful assistant.')
        .addUser('What is your name?')
        .addAssistant('I am an AI assistant.'),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should merge context generated by the subroutine by default', async () => {
    // Create a subroutine that updates context
    const subroutine = new Subroutine(
      new Sequence()
        .addUser('Extract information')
        .addAssistant('Information extracted')
        .addTransform((session: ISession<any>) => {
          return session.updateContext({
            extractedData: { name: 'Alice', age: 30 },
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the context was merged
    expect(session.context.get('extractedData')).toEqual({
      name: 'Alice',
      age: 30,
    });
  });

  it('should respect the retainMessages flag', async () => {
    // Create a subroutine with retainMessages = false
    const hideMessagesSubroutine = new Subroutine(
      new Sequence()
        .addSystem('Internal system message')
        .addUser('Internal user message')
        .addAssistant('Internal assistant message'),
      { retainMessages: false },
    );

    // Execute the subroutine
    const hideMessagesSession =
      await hideMessagesSubroutine.execute(createSession());

    // Verify no messages were retained (default merge logic keeps parent messages)
    const hideMessages = Array.from(hideMessagesSession.messages);
    expect(hideMessages).toHaveLength(0); // Parent session was empty

    // Create a subroutine with retainMessages = true (default)
    const showMessagesSubroutine = new Subroutine(
      new Sequence()
        .addSystem('Visible system message')
        .addUser('Visible user message')
        .addAssistant('Visible assistant message'),
    );

    // Execute the subroutine
    const showMessagesSession =
      await showMessagesSubroutine.execute(createSession());

    // Verify messages were retained
    const showMessages = Array.from(showMessagesSession.messages);
    expect(showMessages).toHaveLength(3);
  });

  it('should use parent session context by default', async () => {
    // Create a parent session with context
    const parentSession = createSession<{ userName: string }>().updateContext({
      userName: 'Bob',
    });

    // Add a message to the parent session
    const sessionWithMessage = parentSession.addMessage({
      type: 'system',
      content: 'Parent system message',
    });

    // Create a subroutine that uses parent context (via default initWith)
    const subroutine = new Subroutine<{ userName: string }>(
      new Sequence()
        .addUser(
          new (class extends Source<string> {
            async getContent(session: ISession<any>) {
              return `Hello, ${(session.context as Context<any>).get('userName')}!`;
            }
          })(),
        )
        .addAssistant('Nice to meet you!'),
    );

    // Execute the subroutine with the parent session
    const resultSession = await subroutine.execute(sessionWithMessage);

    // Verify the messages (parent + new)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('Parent system message');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('Hello, Bob!'); // Interpolated correctly
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('Nice to meet you!');
    // Verify parent context is still there
    expect(resultSession.context.get('userName')).toBe('Bob');
  });

  it('should allow transformers within the subroutine template', async () => {
    // Mock a more complex response with data to extract
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'The weather in Tokyo is 25°C and sunny.',
      metadata: createContext(),
    });

    // Create a subroutine with a transformer *inside* the Sequence
    const subroutine = new Subroutine(
      new Sequence()
        .addUser('What is the weather in Tokyo?')
        .addAssistant(
          createGenerateOptions({
            provider: {
              type: 'openai',
              apiKey: 'test-api-key',
              modelName: 'gpt-4o-mini',
            },
          }),
        )
        .addTransform((session: ISession<any>) => {
          const lasMessage = session.getLastMessage();
          const content = lasMessage?.content || '';
          const tempMatch = content.match(/(\d+)°C/);
          const temperature = tempMatch ? parseInt(tempMatch[1]) : null;
          const weatherMatch = content.match(/(sunny|cloudy|rainy|snowy)/i);
          const weatherCondition = weatherMatch
            ? weatherMatch[1].toLowerCase()
            : null;
          return session.updateContext({
            weatherData: {
              location: 'Tokyo',
              temperature,
              condition: weatherCondition,
            },
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(2); // User, Assistant

    // Verify the extracted context was merged back
    const weatherData = session.context.get('weatherData') as any;
    expect(weatherData).toBeDefined();
    expect(weatherData.location).toBe('Tokyo');
    expect(weatherData.temperature).toBe(25);
    expect(weatherData.condition).toBe('sunny');
  });

  it('should handle nested subroutines (original style)', async () => {
    // Create an inner subroutine
    const innerSubroutine = new Subroutine(
      new Sequence()
        .addUser('Inner subroutine question')
        .addAssistant('Inner subroutine answer')
        .addTransform((session: ISession<any>) => {
          return session.updateContext({
            inner: 'completed',
          }) as ISession<any>;
        }),
    );

    // Create an outer subroutine that includes the inner one
    const outerSubroutine = new Subroutine(
      new Sequence()
        .addUser('Outer subroutine start')
        .add(innerSubroutine) // Nest the subroutine
        .addUser('Outer subroutine end')
        .addTransform((session: ISession<any>) => {
          return session.updateContext({
            outer: 'completed',
          }) as ISession<any>;
        }),
    );

    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages (all should be retained by default)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer subroutine start');
    expect(messages[1].content).toBe('Inner subroutine question');
    expect(messages[2].content).toBe('Inner subroutine answer');
    expect(messages[3].content).toBe('Outer subroutine end');

    // Verify the context from both subroutines was merged (default behavior)
    expect(session.context.get('inner')).toBe('completed');
    expect(session.context.get('outer')).toBe('completed');
  });

  it('should support isolatedContext mode', async () => {
    // Use ISession<any> for parent to allow checking dynamic keys later if needed
    const parentSession = createSession<any>().updateContext({
      parentData: 'visible',
    });

    // Create a subroutine with isolatedContext = true
    const isolatedSubroutine = new Subroutine<any, any>(
      new Sequence()
        .addUser('Testing isolated context')
        .addTransform((session: ISession<any>) => {
          // Try to access parent context (should be undefined due to isolated context)
          const parentData = session.context.get('parentData');
          // Set new context in the isolated context
          return session.updateContext({
            isolatedData: 'not visible to parent',
            parentDataVisible: parentData !== undefined, // This will be false
          }) as ISession<any>;
        }),
      { isolatedContext: true },
    );

    // Execute the subroutine
    const resultSession = await isolatedSubroutine.execute(parentSession);

    // Verify the parent session received the user message (retainMessages is true by default)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1);
    expect(messages[0].content).toBe('Testing isolated context');

    // The isolatedData should NOT be available in the result due to isolated context
    expect(
      (resultSession.context as Context<any>).get('isolatedData'),
    ).toBeUndefined();

    // The parentDataVisible context (set inside isolated context) should also NOT be merged back
    expect(
      (resultSession.context as Context<any>).get('parentDataVisible'),
    ).toBeUndefined();

    // Parent context should remain unchanged
    expect(resultSession.context.get('parentData')).toBe('visible');

    // --- Test shared context (default) ---
    const sharedSubroutine = new Subroutine<any, any>(
      new Sequence()
        .addUser('Testing shared context')
        .addTransform((session: ISession<any>) => {
          // Try to access parent context (should be visible via default initWith)
          const parentData = session.context.get('parentData');
          // Set new context in the shared context
          return session.updateContext({
            sharedData: 'visible to parent',
            parentDataVisible: parentData !== undefined, // This will be true
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const sharedResultSession = await sharedSubroutine.execute(parentSession);

    // The sharedData should be available in the result (merged by default squashWith)
    expect(
      (sharedResultSession.context as Context<any>).get('sharedData'),
    ).toBe('visible to parent');

    // The parentDataVisible should be true and merged back
    expect(
      (sharedResultSession.context as Context<any>).get('parentDataVisible'),
    ).toBe(true);

    // Parent context should still be there
    expect(sharedResultSession.context.get('parentData')).toBe('visible');
  });

  it('should use the initWith function when provided', async () => {
    // Create a custom session initializer function (initWith)
    const customInitWith = vi
      .fn()
      .mockImplementation((parentSession: ISession<any>) => {
        // Create a new session, selectively copying context
        const newSession = createSession<any>();
        const userName = parentSession.context.get('userName');
        if (userName) {
          newSession.context.set('userName', userName);
        }
        // Add custom initialization context
        newSession.context.set('customInit', true);
        // Don't copy messages for this test
        return newSession;
      });

    // Create a parent session with various context
    const parentSession = createSession<any>()
      .updateContext({ userName: 'Charlie' })
      .updateContext({ sensitiveData: 'should not be copied' });

    // Create a subroutine with the custom initWith function
    const subroutine = new Subroutine<any, any>(
      new Sequence().addUser(
        new (class extends Source<string> {
          async getContent(session: ISession<any>) {
            const userName = (session.context as Context<any>).get('userName');
            const customInit = (session.context as Context<any>).get(
              'customInit',
            );
            const sensitiveData = (session.context as Context<any>).get(
              'sensitiveData',
            );
            return `User: ${userName}, Custom: ${customInit}, Sensitive: ${
              sensitiveData === undefined ? 'protected' : 'exposed'
            }`;
          }
        })(),
      ),
      { initWith: customInitWith },
    );

    // Execute the subroutine
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom initWith function was called
    expect(customInitWith).toHaveBeenCalledWith(parentSession);

    // Verify the message reflects the custom session initialization
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1); // Only the addUser message from subroutine
    expect(messages[0].content).toBe(
      'User: Charlie, Custom: true, Sensitive: protected',
    );
    // Verify context reflects custom init and default merge
    expect(resultSession.context.get('userName')).toBe('Charlie'); // From parent via initWith
    expect((resultSession.context as Context<any>).get('customInit')).toBe(
      true,
    );
    expect(resultSession.context.get('sensitiveData')).toBe(
      'should not be copied',
    );
  });

  it('should use the squashWith function when provided', async () => {
    // Create a parent session with nested context
    let parentSession = createSession<any>().updateContext({
      user: { name: 'Dave', age: 30 },
    });
    parentSession = parentSession.updateContext({
      preferences: { theme: 'dark' },
    });

    // Create a custom merger function (squashWith)
    const customSquashWith = vi
      .fn()
      .mockImplementation(
        (parent: ISession<any>, subroutine: ISession<any>) => {
          // Start with a clone of the parent's context object
          const mergedMetadataObject = { ...parent.context.toObject() };

          const subroutineMeta = subroutine.context.toObject();

          // Deep merge 'user' object
          if (subroutineMeta.user && typeof subroutineMeta.user === 'object') {
            const currentUser = mergedMetadataObject.user || {};
            // Ensure name from parent is kept if not overwritten by subroutine
            mergedMetadataObject.user = {
              ...currentUser,
              ...subroutineMeta.user,
            };
          }

          // Simple overwrite for 'preferences'
          if (subroutineMeta.preferences) {
            mergedMetadataObject.preferences = subroutineMeta.preferences;
          }

          // Add/overwrite any other keys from subroutine
          for (const key in subroutineMeta) {
            if (
              key !== 'user' &&
              key !== 'preferences' &&
              subroutineMeta.hasOwnProperty(key)
            ) {
              mergedMetadataObject[key] = subroutineMeta[key];
            }
          }

          // Create final session - use merged context object
          let finalSession = createSession({ context: mergedMetadataObject });
          // Add parent messages (as per this test's custom logic)
          parent.messages.forEach(
            (msg) => (finalSession = finalSession.addMessage(msg)),
          );

          return finalSession;
        },
      );

    // Create a subroutine with the custom squashWith function
    const subroutine = new Subroutine<any, any>(
      new Sequence()
        .addUser('Updating user profile')
        .addTransform((session: ISession<any>) => {
          // This context will be processed by squashWith
          return session.updateContext({
            user: { age: 31, occupation: 'Engineer' }, // Update age, add occupation
            preferences: { notifications: true }, // Overwrite preferences
            status: 'updated', // Add new key
          }) as ISession<any>;
        }),
      { squashWith: customSquashWith },
    );

    // Execute the subroutine
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom squashWith function was called
    expect(customSquashWith).toHaveBeenCalled();

    // Verify the messages (only parent messages kept by this squashWith)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(0); // Parent session started empty

    // Verify the deep-merged context according to custom logic
    const user = resultSession.context.get('user');
    expect(user).toEqual({ name: 'Dave', age: 31, occupation: 'Engineer' });

    const preferences = resultSession.context.get('preferences');
    expect(preferences).toEqual({ notifications: true }); // Overwritten

    expect((resultSession.context as Context<any>).get('status')).toBe(
      'updated',
    );
  });

  // New functionality tests for list of templates and method chaining

  it('should support adding multiple templates via method chaining', async () => {
    // Create a subroutine template with method chaining
    const subroutine = new Subroutine()
      .addSystem('You are a helpful assistant.')
      .addUser('What is your name?')
      .addAssistant('I am an AI assistant.');

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should support adding templates via constructor array', async () => {
    // Create a subroutine template with constructor array
    const subroutine = new Subroutine([
      new System('You are a helpful assistant.'),
      new User('What is your name?'),
      new Assistant('I am an AI assistant.'),
    ]);

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should support nested subroutines with method chaining', async () => {
    // Create an inner subroutine with method chaining
    const innerSubroutine = new Subroutine()
      .addUser('Inner subroutine question')
      .addAssistant('Inner subroutine answer')
      .addTransform((session: ISession<any>) => {
        return session.updateContext({ inner: 'completed' }) as ISession<any>;
      });

    // Create an outer subroutine that includes the inner one via method chaining
    const outerSubroutine = new Subroutine()
      .addUser('Outer subroutine start')
      .add(innerSubroutine) // Nest the subroutine
      .addUser('Outer subroutine end')
      .addTransform((session: ISession<any>) => {
        return session.updateContext({ outer: 'completed' }) as ISession<any>;
      });

    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages (all should be retained by default)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer subroutine start');
    expect(messages[1].content).toBe('Inner subroutine question');
    expect(messages[2].content).toBe('Inner subroutine answer');
    expect(messages[3].content).toBe('Outer subroutine end');

    // Verify the context from both subroutines was merged (default behavior)
    expect(session.context.get('inner')).toBe('completed');
    expect(session.context.get('outer')).toBe('completed');
  });

  it('should support adding subroutines to LinearTemplate (Sequence)', async () => {
    // Create a subroutine
    const nestedSubroutine = new Subroutine(
      new Sequence()
        .addUser('Message from nested subroutine')
        .addAssistant('Response from nested subroutine'),
    );

    // Create a sequence that includes the subroutine
    const sequence = new Sequence()
      .addSystem('Main sequence system message')
      .add(nestedSubroutine) // Add the subroutine
      .addUser('Message after nested subroutine');

    // Execute the sequence
    const session = await sequence.execute(createSession());

    // Verify the messages from both the sequence and the subroutine are present
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Main sequence system message');
    expect(messages[1].content).toBe('Message from nested subroutine');
    expect(messages[2].content).toBe('Response from nested subroutine');
    expect(messages[3].content).toBe('Message after nested subroutine');
  });

  it('should support adding subroutines to LoopTemplate', async () => {
    // Create a counter for the loop condition
    let counter = 0;
    const exitCondition = () => {
      counter++;
      return counter >= 2; // Exit after 2 iterations
    };

    // Create a subroutine to be used in the loop body
    const loopSubroutine = new Subroutine(
      new Sequence()
        .addUser('Message from loop subroutine')
        .addTransform((session: ISession<any>) => {
          const currentCount = (session.context.get('count') as number) || 0;
          return session.updateContext({
            count: currentCount + 1,
          });
        }),
    );

    // Create a loop template that includes the subroutine in its body
    const loopTemplate = new Loop({
      bodyTemplate: loopSubroutine, // Use the subroutine as the body
      exitCondition: exitCondition,
    });

    // Execute the loop, starting context count at 0
    const session = await loopTemplate.execute(
      createSession({ context: { count: 0 } }) as unknown as ISession<
        Record<string, unknown>
      >,
    );

    // Should have executed the loop body (subroutine) 1 time (exit condition counter >= 2)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(1); // 1 message from subroutine * 1 iteration
    expect(messages[0].content).toBe('Message from loop subroutine');

    // Verify the count was incremented to 1 (executed once)
    expect(session.context.get('count')).toBe(1);
  });

  it('should work with direct loop implementation', async () => {
    const counterTemplate = TemplateFactory.transform((session: Session) => {
      const currentCount = (session.context.get('count') as number) || 0;
      return session.updateContext({ count: currentCount + 1 });
    });

    const loop = TemplateFactory.loop(counterTemplate, (session: Session) => {
      const count = (session.context.get('count') as number) || 0;
      return count >= 3; // Exit when count reaches 3 or more
    });

    const initialSession = createSession().updateContext({ count: 0 });
    const session = await loop.execute(initialSession);

    // Verify the count was incremented to 3
    expect(session.context.get('count')).toBe(3);
  });

  it('should handle empty templates list gracefully', async () => {
    // Create a subroutine with an empty list of templates
    const subroutine = new Subroutine([]);

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify no messages were added
    expect(session.messages).toHaveLength(0);
  });
});
