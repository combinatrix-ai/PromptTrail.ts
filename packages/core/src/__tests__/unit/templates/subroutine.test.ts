import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createSession } from '../../../session';
import { createGenerateOptions } from '../../../generate_options';
import { createMetadata } from '../../../metadata';
import { generateText } from '../../../generate';
import { Source } from '../../../content_source';
import { SubroutineTemplate, Sequence, LoopTemplate } from '../../../templates';
import { TemplateFactory } from '../../../templates/factory';
import type { ISession, Session } from '../../../types';
import type { Metadata } from '../../../metadata';

// Mock the generate module
vi.mock('../../../generate', () => ({
  generateText: vi.fn(),
}));

describe('SubroutineTemplate', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Set up default mock for generateText
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'Mock response',
      metadata: createMetadata(),
    });
  });

  // Original functionality tests

  it('should execute a simple subroutine and merge results by default', async () => {
    // Create a subroutine template with a simple sequence
    const subroutine = new SubroutineTemplate(
      new Sequence()
        .addSystem('You are a helpful assistant.')
        .addUser('What is your name?')
        .addAssistant('I am an AI assistant.'),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should merge metadata generated by the subroutine by default', async () => {
    // Create a subroutine that updates metadata
    const subroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('Extract information')
        .addAssistant('Information extracted')
        .addTransform((session: ISession<any>) => {
          return session.updateMetadata({
            extractedData: { name: 'Alice', age: 30 },
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the metadata was merged
    expect(session.metadata.get('extractedData')).toEqual({
      name: 'Alice',
      age: 30,
    });
  });

  it('should respect the retainMessages flag', async () => {
    // Create a subroutine with retainMessages = false
    const hideMessagesSubroutine = new SubroutineTemplate(
      new Sequence()
        .addSystem('Internal system message')
        .addUser('Internal user message')
        .addAssistant('Internal assistant message'),
      { retainMessages: false },
    );

    // Execute the subroutine
    const hideMessagesSession =
      await hideMessagesSubroutine.execute(createSession());

    // Verify no messages were retained (default merge logic keeps parent messages)
    const hideMessages = Array.from(hideMessagesSession.messages);
    expect(hideMessages).toHaveLength(0); // Parent session was empty

    // Create a subroutine with retainMessages = true (default)
    const showMessagesSubroutine = new SubroutineTemplate(
      new Sequence()
        .addSystem('Visible system message')
        .addUser('Visible user message')
        .addAssistant('Visible assistant message'),
    );

    // Execute the subroutine
    const showMessagesSession =
      await showMessagesSubroutine.execute(createSession());

    // Verify messages were retained
    const showMessages = Array.from(showMessagesSession.messages);
    expect(showMessages).toHaveLength(3);
  });

  it('should use parent session context by default', async () => {
    // Create a parent session with metadata
    const parentSession = createSession<{ userName: string }>().updateMetadata({
      userName: 'Bob',
    });

    // Add a message to the parent session
    const sessionWithMessage = parentSession.addMessage({
      type: 'system',
      content: 'Parent system message',
    });

    // Create a subroutine that uses parent context (via default initWith)
    const subroutine = new SubroutineTemplate<{ userName: string }>(
      new Sequence()
        .addUser(
          new (class extends Source<string> {
            async getContent(session: ISession<any>) {
              return `Hello, ${(session.metadata as Metadata<any>).get('userName')}!`;
            }
          })(),
        )
        .addAssistant('Nice to meet you!'),
    );

    // Execute the subroutine with the parent session
    const resultSession = await subroutine.execute(sessionWithMessage);

    // Verify the messages (parent + new)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('Parent system message');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('Hello, Bob!'); // Interpolated correctly
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('Nice to meet you!');
    // Verify parent metadata is still there
    expect(resultSession.metadata.get('userName')).toBe('Bob');
  });

  it('should allow transformers within the subroutine template', async () => {
    // Mock a more complex response with data to extract
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'The weather in Tokyo is 25°C and sunny.',
      metadata: createMetadata(),
    });

    // Create a subroutine with a transformer *inside* the Sequence
    const subroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('What is the weather in Tokyo?')
        .addAssistant(
          createGenerateOptions({
            provider: {
              type: 'openai',
              apiKey: 'test-api-key',
              modelName: 'gpt-4o-mini',
            },
          }),
        )
        .addTransform((session: ISession<any>) => {
          const lastMessage = session.getLastMessage();
          const content = lastMessage?.content || '';
          const tempMatch = content.match(/(\d+)°C/);
          const temperature = tempMatch ? parseInt(tempMatch[1]) : null;
          const weatherMatch = content.match(/(sunny|cloudy|rainy|snowy)/i);
          const weatherCondition = weatherMatch
            ? weatherMatch[1].toLowerCase()
            : null;
          return session.updateMetadata({
            weatherData: {
              location: 'Tokyo',
              temperature,
              condition: weatherCondition,
            },
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(2); // User, Assistant

    // Verify the extracted metadata was merged back
    const weatherData = session.metadata.get('weatherData') as any;
    expect(weatherData).toBeDefined();
    expect(weatherData.location).toBe('Tokyo');
    expect(weatherData.temperature).toBe(25);
    expect(weatherData.condition).toBe('sunny');
  });

  it('should handle nested subroutines (original style)', async () => {
    // Create an inner subroutine
    const innerSubroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('Inner subroutine question')
        .addAssistant('Inner subroutine answer')
        .addTransform((session: ISession<any>) => {
          return session.updateMetadata({
            inner: 'completed',
          }) as ISession<any>;
        }),
    );

    // Create an outer subroutine that includes the inner one
    const outerSubroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('Outer subroutine start')
        .add(innerSubroutine) // Nest the subroutine
        .addUser('Outer subroutine end')
        .addTransform((session: ISession<any>) => {
          return session.updateMetadata({
            outer: 'completed',
          }) as ISession<any>;
        }),
    );

    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages (all should be retained by default)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer subroutine start');
    expect(messages[1].content).toBe('Inner subroutine question');
    expect(messages[2].content).toBe('Inner subroutine answer');
    expect(messages[3].content).toBe('Outer subroutine end');

    // Verify the metadata from both subroutines was merged (default behavior)
    expect(session.metadata.get('inner')).toBe('completed');
    expect(session.metadata.get('outer')).toBe('completed');
  });

  it('should support isolatedContext mode', async () => {
    // Use ISession<any> for parent to allow checking dynamic keys later if needed
    const parentSession = createSession<any>().updateMetadata({
      parentData: 'visible',
    });

    // Create a subroutine with isolatedContext = true
    const isolatedSubroutine = new SubroutineTemplate<any, any>(
      new Sequence()
        .addUser('Testing isolated context')
        .addTransform((session: ISession<any>) => {
          // Try to access parent metadata (should be undefined due to isolated context)
          const parentData = session.metadata.get('parentData');
          // Set new metadata in the isolated context
          return session.updateMetadata({
            isolatedData: 'not visible to parent',
            parentDataVisible: parentData !== undefined, // This will be false
          }) as ISession<any>;
        }),
      { isolatedContext: true },
    );

    // Execute the subroutine
    const resultSession = await isolatedSubroutine.execute(parentSession);

    // Verify the parent session received the user message (retainMessages is true by default)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1);
    expect(messages[0].content).toBe('Testing isolated context');

    // The isolatedData should NOT be available in the result due to isolated context
    expect(
      (resultSession.metadata as Metadata<any>).get('isolatedData'),
    ).toBeUndefined();

    // The parentDataVisible metadata (set inside isolated context) should also NOT be merged back
    expect(
      (resultSession.metadata as Metadata<any>).get('parentDataVisible'),
    ).toBeUndefined();

    // Parent metadata should remain unchanged
    expect(resultSession.metadata.get('parentData')).toBe('visible');

    // --- Test shared context (default) ---
    const sharedSubroutine = new SubroutineTemplate<any, any>(
      new Sequence()
        .addUser('Testing shared context')
        .addTransform((session: ISession<any>) => {
          // Try to access parent metadata (should be visible via default initWith)
          const parentData = session.metadata.get('parentData');
          // Set new metadata in the shared context
          return session.updateMetadata({
            sharedData: 'visible to parent',
            parentDataVisible: parentData !== undefined, // This will be true
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const sharedResultSession = await sharedSubroutine.execute(parentSession);

    // The sharedData should be available in the result (merged by default squashWith)
    expect(
      (sharedResultSession.metadata as Metadata<any>).get('sharedData'),
    ).toBe('visible to parent');

    // The parentDataVisible should be true and merged back
    expect(
      (sharedResultSession.metadata as Metadata<any>).get('parentDataVisible'),
    ).toBe(true);

    // Parent metadata should still be there
    expect(sharedResultSession.metadata.get('parentData')).toBe('visible');
  });

  it('should use the initWith function when provided', async () => {
    // Create a custom session initializer function (initWith)
    const customInitWith = vi
      .fn()
      .mockImplementation((parentSession: ISession<any>) => {
        // Create a new session, selectively copying metadata
        const newSession = createSession<any>();
        const userName = parentSession.metadata.get('userName');
        if (userName) {
          newSession.metadata.set('userName', userName);
        }
        // Add custom initialization metadata
        newSession.metadata.set('customInit', true);
        // Don't copy messages for this test
        return newSession;
      });

    // Create a parent session with various metadata
    const parentSession = createSession<any>()
      .updateMetadata({ userName: 'Charlie' })
      .updateMetadata({ sensitiveData: 'should not be copied' });

    // Create a subroutine with the custom initWith function
    const subroutine = new SubroutineTemplate<any, any>(
      new Sequence().addUser(
        new (class extends Source<string> {
          async getContent(session: ISession<any>) {
            const userName = (session.metadata as Metadata<any>).get(
              'userName',
            );
            const customInit = (session.metadata as Metadata<any>).get(
              'customInit',
            );
            const sensitiveData = (session.metadata as Metadata<any>).get(
              'sensitiveData',
            );
            return `User: ${userName}, Custom: ${customInit}, Sensitive: ${
              sensitiveData === undefined ? 'protected' : 'exposed'
            }`;
          }
        })(),
      ),
      { initWith: customInitWith },
    );

    // Execute the subroutine
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom initWith function was called
    expect(customInitWith).toHaveBeenCalledWith(parentSession);

    // Verify the message reflects the custom session initialization
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1); // Only the addUser message from subroutine
    expect(messages[0].content).toBe(
      'User: Charlie, Custom: true, Sensitive: protected',
    );
    // Verify metadata reflects custom init and default merge
    expect(resultSession.metadata.get('userName')).toBe('Charlie'); // From parent via initWith
    expect((resultSession.metadata as Metadata<any>).get('customInit')).toBe(
      true,
    );
    expect(resultSession.metadata.get('sensitiveData')).toBe(
      'should not be copied',
    );
  });

  it('should use the squashWith function when provided', async () => {
    // Create a parent session with nested metadata
    let parentSession = createSession<any>().updateMetadata({
      user: { name: 'Dave', age: 30 },
    });
    parentSession = parentSession.updateMetadata({
      preferences: { theme: 'dark' },
    });

    // Create a custom merger function (squashWith)
    const customSquashWith = vi
      .fn()
      .mockImplementation(
        (parent: ISession<any>, subroutine: ISession<any>) => {
          // Start with a clone of the parent's metadata object
          const mergedMetadataObject = { ...parent.metadata.toObject() };

          const subroutineMeta = subroutine.metadata.toObject();

          // Deep merge 'user' object
          if (subroutineMeta.user && typeof subroutineMeta.user === 'object') {
            const currentUser = mergedMetadataObject.user || {};
            // Ensure name from parent is kept if not overwritten by subroutine
            mergedMetadataObject.user = {
              ...currentUser,
              ...subroutineMeta.user,
            };
          }

          // Simple overwrite for 'preferences'
          if (subroutineMeta.preferences) {
            mergedMetadataObject.preferences = subroutineMeta.preferences;
          }

          // Add/overwrite any other keys from subroutine
          for (const key in subroutineMeta) {
            if (
              key !== 'user' &&
              key !== 'preferences' &&
              subroutineMeta.hasOwnProperty(key)
            ) {
              mergedMetadataObject[key] = subroutineMeta[key];
            }
          }

          // Create final session - use merged metadata object
          let finalSession = createSession({ metadata: mergedMetadataObject });
          // Add parent messages (as per this test's custom logic)
          parent.messages.forEach(
            (msg) => (finalSession = finalSession.addMessage(msg)),
          );

          return finalSession;
        },
      );

    // Create a subroutine with the custom squashWith function
    const subroutine = new SubroutineTemplate<any, any>(
      new Sequence()
        .addUser('Updating user profile')
        .addTransform((session: ISession<any>) => {
          // This metadata will be processed by squashWith
          return session.updateMetadata({
            user: { age: 31, occupation: 'Engineer' }, // Update age, add occupation
            preferences: { notifications: true }, // Overwrite preferences
            status: 'updated', // Add new key
          }) as ISession<any>;
        }),
      { squashWith: customSquashWith },
    );

    // Execute the subroutine
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom squashWith function was called
    expect(customSquashWith).toHaveBeenCalled();

    // Verify the messages (only parent messages kept by this squashWith)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(0); // Parent session started empty

    // Verify the deep-merged metadata according to custom logic
    const user = resultSession.metadata.get('user');
    expect(user).toEqual({ name: 'Dave', age: 31, occupation: 'Engineer' });

    const preferences = resultSession.metadata.get('preferences');
    expect(preferences).toEqual({ notifications: true }); // Overwritten

    expect((resultSession.metadata as Metadata<any>).get('status')).toBe(
      'updated',
    );
  });

  // New functionality tests for list of templates and method chaining

  it('should support adding multiple templates via method chaining', async () => {
    // Create a subroutine template with method chaining
    const subroutine = new SubroutineTemplate()
      .addSystem('You are a helpful assistant.')
      .addUser('What is your name?')
      .addAssistant('I am an AI assistant.');

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should support adding templates via constructor array', async () => {
    // Create templates to add
    const systemTemplate = new SubroutineTemplate().addSystem(
      'System instruction',
    );
    const userTemplate = new SubroutineTemplate().addUser('User message');
    const assistantTemplate = new SubroutineTemplate().addAssistant(
      'Assistant response',
    );

    // Create a subroutine with an array of templates
    const subroutine = new SubroutineTemplate([
      systemTemplate,
      userTemplate,
      assistantTemplate,
    ]);

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify all templates were executed
    const messages = Array.from(session.messages);
    expect(messages.length).toBeGreaterThan(0);
  });

  it('should support nested subroutines with method chaining', async () => {
    // Create a nested subroutine
    const innerSubroutine = new SubroutineTemplate()
      .addUser('Inner question')
      .addAssistant('Inner answer')
      .addTransform((session: ISession<any>) => {
        return session.updateMetadata({
          inner: 'completed',
        }) as ISession<any>;
      });

    // Create an outer subroutine that includes the inner one
    const outerSubroutine = new SubroutineTemplate()
      .addUser('Outer start')
      .addSubroutine(innerSubroutine)
      .addUser('Outer end')
      .addTransform((session: ISession<any>) => {
        return session.updateMetadata({
          outer: 'completed',
        }) as ISession<any>;
      });

    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer start');
    expect(messages[1].content).toBe('Inner question');
    expect(messages[2].content).toBe('Inner answer');
    expect(messages[3].content).toBe('Outer end');

    // Verify the metadata
    expect(session.metadata.get('inner')).toBe('completed');
    expect(session.metadata.get('outer')).toBe('completed');
  });

  it('should support adding subroutines to LinearTemplate (Sequence)', async () => {
    // Create a subroutine
    const subroutine = new SubroutineTemplate()
      .addUser('Subroutine question')
      .addAssistant('Subroutine answer');

    // Create a sequence that includes the subroutine
    const sequence = new Sequence()
      .addSystem('Main system message')
      .addSubroutine(subroutine)
      .addUser('Final user message');

    // Execute the sequence
    const session = await sequence.execute(createSession());

    // Verify the messages
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('Main system message');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('Subroutine question');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('Subroutine answer');
    expect(messages[3].type).toBe('user');
    expect(messages[3].content).toBe('Final user message');
  });

  it('should support adding subroutines to LoopTemplate', async () => {
    // Create a session with initial metadata
    const initialSession = createSession<{ count: number }>().updateMetadata({
      count: 0,
    });

    // Create a simple subroutine that adds a user message and increments count
    const subroutine = new SubroutineTemplate()
      .addUser('Loop iteration')
      .addTransform((session: ISession<any>) => {
        const currentCount = (session.metadata.get('count') as number) || 0;
        return session.updateMetadata({
          count: currentCount + 1,
        }) as ISession<any>;
      });

    // Create a loop that uses addSubroutine
    const loop = new LoopTemplate<{ count: number }>()
      .addSubroutine(subroutine)
      .setLoopIf((session) => {
        const count = (session.metadata.get('count') as number) || 0;
        return count >= 3; // Exit when count reaches 3 or more
      });

    // Execute the loop
    const session = await loop.execute(initialSession);

    // Verify the count was incremented to 3
    expect(session.metadata.get('count')).toBe(3);

    // Verify the messages (3 iterations with 1 user message per iteration)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages.filter((m) => m.type === 'user').length).toBe(3);
  });

  it('should work with direct loop implementation', async () => {
    // Create a session with initial metadata
    const initialSession = createSession().updateMetadata({ count: 0 });

    // Create a simple counter template using transform
    const counterTemplate = TemplateFactory.transform((session: Session) => {
      const currentCount = (session.metadata.get('count') as number) || 0;

      return session.updateMetadata({
        count: currentCount + 1,
      });
    });

    // Create a loop directly using TemplateFactory
    const loop = TemplateFactory.loop(counterTemplate, (session: Session) => {
      const count = (session.metadata.get('count') as number) || 0;
      return count >= 3; // Exit when count reaches 3 or more
    });

    // Execute the loop
    const session = await loop.execute(initialSession);

    // Verify the count was incremented to 3
    expect(session.metadata.get('count')).toBe(3);
  });

  it('should handle empty templates list gracefully', async () => {
    // Create a subroutine with no templates
    const subroutine = new SubroutineTemplate();

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify no messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(0);
  });
});
