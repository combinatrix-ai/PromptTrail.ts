import { beforeEach, describe, expect, it, vi } from 'vitest';
import { generateText } from '../../../generate';
import type { Session } from '../../../session';
import { createSession } from '../../../session';
import { Source } from '../../../source';
import { Attrs, Vars } from '../../../tagged_record';
import {
  Agent,
  Assistant,
  Loop,
  Subroutine,
  System,
  Transform,
  User,
} from '../../../templates';

// Mock the generate module
vi.mock('../../../generate', () => ({
  generateText: vi.fn(),
}));

describe('SubroutineTemplate', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Set up default mock for generateText
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'Mock response',
    });
  });

  // Original functionality tests

  it('should execute a simple subroutine and merge results by default', async () => {
    // Create a subroutine template with a simple sequence
    const subroutine = new Subroutine(
      new Agent()
        .addSystem('You are a helpful assistant.')
        .addUser('What is your name?')
        .addAssistant('I am an AI assistant.'),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should merge context generated by the subroutine by default', async () => {
    // Create a subroutine that updates context
    const subroutine = new Subroutine(
      new Agent()
        .addUser('Extract information')
        .addAssistant('Information extracted')
        .addTransform((session: Session<any>) => {
          return session.withVars({
            extractedData: { name: 'Alice', age: 30 },
          }) as Session<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the context was merged
    expect(session.getVar('extractedData')).toEqual({
      name: 'Alice',
      age: 30,
    });
  });

  it('should respect the retainMessages flag', async () => {
    // Create a subroutine with retainMessages = false
    const hideMessagesSubroutine = new Subroutine(
      new Agent()
        .addSystem('Internal system message')
        .addUser('Internal user message')
        .addAssistant('Internal assistant message'),
      { retainMessages: false },
    );

    // Execute the subroutine
    const hideMessagesSession =
      await hideMessagesSubroutine.execute(createSession());

    // Verify no messages were retained (default merge logic keeps parent messages)
    const hideMessages = Array.from(hideMessagesSession.messages);
    expect(hideMessages).toHaveLength(0); // Parent session was empty

    // Create a subroutine with retainMessages = true (default)
    const showMessagesSubroutine = new Subroutine(
      new Agent()
        .addSystem('Visible system message')
        .addUser('Visible user message')
        .addAssistant('Visible assistant message'),
    );

    // Execute the subroutine
    const showMessagesSession =
      await showMessagesSubroutine.execute(createSession());

    // Verify messages were retained
    const showMessages = Array.from(showMessagesSession.messages);
    expect(showMessages).toHaveLength(3);
  });

  it('should use parent session context by default', async () => {
    type SharedContext = Vars<{ userName: string }>;
    // Create a parent session with context
    const parentSession = createSession<SharedContext, Attrs>().withVars({
      userName: 'Bob',
    });

    // Add a message to the parent session
    const sessionWithMessage = parentSession.addMessage({
      type: 'system',
      content: 'Parent system message',
    });

    // Create a subroutine that uses parent context (via default initWith)
    const subroutine = new Subroutine<Attrs, SharedContext>(
      new Agent<SharedContext>()
        .addUser(
          new (class extends Source<string> {
            async getContent(session: Session<SharedContext>) {
              return `Hello, ${session.getVar('userName')}!`;
            }
          })(),
        )
        .addAssistant('Nice to meet you!'),
    );

    // Execute the subroutine with the parent session
    const resultSession = await subroutine.execute(sessionWithMessage);

    // Verify the messages (parent + new)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('Parent system message');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('Hello, Bob!'); // Interpolated correctly
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('Nice to meet you!');
    // Verify parent context is still there
    expect(resultSession.getVar('userName')).toBe('Bob');
  });

  it('should allow transformers within the subroutine template', async () => {
    // Mock a more complex response with data to extract
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'The weather in Tokyo is 25°C and sunny.',
    });

    // Create a subroutine with a transformer *inside* the Sequence
    const subroutine = new Subroutine(
      new Agent()
        .addUser('What is the weather in Tokyo?')
        .addAssistant(Source.llm())
        .addTransform((session: Session<any>) => {
          const lasMessage = session.getLastMessage();
          const content = lasMessage?.content || '';
          const tempMatch = content.match(/(\d+)°C/);
          const temperature = tempMatch ? parseInt(tempMatch[1]) : null;
          const weatherMatch = content.match(/(sunny|cloudy|rainy|snowy)/i);
          const weatherCondition = weatherMatch
            ? weatherMatch[1].toLowerCase()
            : null;
          return session.withVars({
            weatherData: {
              location: 'Tokyo',
              temperature,
              condition: weatherCondition,
            },
          }) as Session<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(2); // User, Assistant

    // Verify the extracted context was merged back
    const weatherData = session.getVar('weatherData') as any;
    expect(weatherData).toBeDefined();
    expect(weatherData.location).toBe('Tokyo');
    expect(weatherData.temperature).toBe(25);
    expect(weatherData.condition).toBe('sunny');
  });

  it('should handle nested subroutines (original style)', async () => {
    // Create an inner subroutine
    const innerSubroutine = new Subroutine(
      new Agent()
        .addUser('Inner subroutine question')
        .addAssistant('Inner subroutine answer')
        .addTransform((session: Session<any>) => {
          return session.withVars({
            inner: 'completed',
          }) as Session<any>;
        }),
    );

    // Create an outer subroutine that includes the inner one
    const outerSubroutine = new Subroutine(
      new Agent()
        .addUser('Outer subroutine start')
        .add(innerSubroutine) // Nest the subroutine
        .addUser('Outer subroutine end')
        .addTransform((session: Session<any>) => {
          return session.withVars({
            outer: 'completed',
          }) as Session<any>;
        }),
    );

    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages (all should be retained by default)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer subroutine start');
    expect(messages[1].content).toBe('Inner subroutine question');
    expect(messages[2].content).toBe('Inner subroutine answer');
    expect(messages[3].content).toBe('Outer subroutine end');

    // Verify the context from both subroutines was merged (default behavior)
    expect(session.getVar('inner')).toBe('completed');
    expect(session.getVar('outer')).toBe('completed');
  });

  it('should support isolatedContext mode', async () => {
    // Use Session<any> for parent to allow checking dynamic keys later if needed
    const parentSession = createSession().withVars({
      parentData: 'visible',
    });

    // Create a subroutine with isolatedContext = true
    const isolatedSubroutine = new Subroutine<any, any>(
      new Agent()
        .addUser('Testing isolated context')
        .addTransform((session: Session<any>) => {
          // Try to access parent context (should be undefined due to isolated context)
          const parentData = session.getVar('parentData');
          // Set new context in the isolated context
          return session.withVars({
            isolatedData: 'not visible to parent',
            parentDataVisible: parentData !== undefined, // This will be false
          }) as Session<any>;
        }),
      { isolatedContext: true },
    );

    // Execute the subroutine
    const resultSession = await isolatedSubroutine.execute(parentSession);

    // Verify the parent session received the user message (retainMessages is true by default)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1);
    expect(messages[0].content).toBe('Testing isolated context');

    // The isolatedData should NOT be available in the result due to isolated context
    expect(resultSession.getVar('isolatedData')).toBeUndefined();

    // The parentDataVisible context (set inside isolated context) should also NOT be merged back
    expect(resultSession.getVar('parentDataVisible')).toBeUndefined();

    // Parent context should remain unchanged
    expect(resultSession.getVar('parentData')).toBe('visible');

    // --- Test shared context (default) ---
    const sharedSubroutine = new Subroutine<any, any>(
      new Agent()
        .addUser('Testing shared context')
        .addTransform((session: Session<any>) => {
          // Try to access parent context (should be visible via default initWith)
          const parentData = session.getVar('parentData');
          // Set new context in the shared context
          return session.withVars({
            sharedData: 'visible to parent',
            parentDataVisible: parentData !== undefined, // This will be true
          }) as Session<any>;
        }),
    );

    // Execute the subroutine
    const sharedResultSession = await sharedSubroutine.execute(parentSession);

    // The sharedData should be available in the result (merged by default squashWith)
    expect(sharedResultSession.getVar('sharedData')).toBe('visible to parent');

    // The parentDataVisible should be true and merged back
    expect(sharedResultSession.getVar('parentDataVisible')).toBe(true);

    // Parent context should still be there
    expect(sharedResultSession.getVar('parentData')).toBe('visible');
  });

  it('should use the initWith function when provided', async () => {
    // Create a custom session initializer function (initWith)
    const customInitWith = vi
      .fn()
      .mockImplementation((parentSession: Session<any>) => {
        // Create a new session with the context values we need
        return createSession({
          context: {
            userName: parentSession.getVar('userName'),
            customInit: true,
          },
        });
      });

    // Create a parent session with various context
    const parentSession = createSession()
      .withVars({ userName: 'Charlie' })
      .withVars({ sensitiveData: 'should not be copied' });

    // Create a subroutine with the custom initWith function
    const subroutine = new Subroutine(
      new Agent().addUser(
        new (class extends Source<string> {
          async getContent(session: Session) {
            const userName = session.getVar('userName');
            const customInit = session.getVar('customInit');
            const sensitiveData = session.getVar('sensitiveData');
            return `User: ${userName}, Custom: ${customInit}, Sensitive: ${
              sensitiveData === undefined ? 'protected' : 'exposed'
            }`;
          }
        })(),
      ),
      { initWith: customInitWith },
    );

    // Execute the subroutine
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom initWith function was called
    expect(customInitWith).toHaveBeenCalledWith(parentSession);

    // Verify the message reflects the custom session initialization
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1); // Only the addUser message from subroutine
    expect(messages[0].content).toBe(
      'User: Charlie, Custom: true, Sensitive: protected',
    );
    // Verify context reflects custom init and default merge
    expect(resultSession.getVar('userName')).toBe('Charlie'); // From parent via initWith
    expect(resultSession.getVar('customInit')).toBe(true);
    expect(resultSession.getVar('sensitiveData')).toBe('should not be copied');
  });

  it('should use the squashWith function when provided', async () => {
    // Create a parent session with nested context
    let parentSession = createSession().withVars({
      user: { name: 'Dave', age: 30 },
    });
    parentSession = parentSession.withVars({
      preferences: { theme: 'dark' },
    });

    // Create a custom merger function (squashWith)
    const customSquashWith = vi
      .fn()
      .mockImplementation((parent: Session<any>, subroutine: Session<any>) => {
        // Start with a clone of the parent's context object
        const mergedMetadataObject = { ...parent.getVarsObject() };

        const subroutineMeta = subroutine.getVarsObject();

        // Deep merge 'user' object
        if (subroutineMeta.user && typeof subroutineMeta.user === 'object') {
          const currentUser = mergedMetadataObject.user || {};
          // Ensure name from parent is kept if not overwritten by subroutine
          mergedMetadataObject.user = {
            ...currentUser,
            ...subroutineMeta.user,
          };
        }

        // Simple overwrite for 'preferences'
        if (subroutineMeta.preferences) {
          mergedMetadataObject.preferences = subroutineMeta.preferences;
        }

        // Add/overwrite any other keys from subroutine
        for (const key in subroutineMeta) {
          if (
            key !== 'user' &&
            key !== 'preferences' &&
            subroutineMeta.hasOwnProperty(key)
          ) {
            mergedMetadataObject[key] = subroutineMeta[key];
          }
        }

        // Create final session - use merged context object
        let finalSession = createSession({ context: mergedMetadataObject });
        // Add parent messages (as per this test's custom logic)
        parent.messages.forEach(
          (msg) => (finalSession = finalSession.addMessage(msg)),
        );

        return finalSession;
      });

    // Create a subroutine with the custom squashWith function
    const subroutine = new Subroutine(
      new Agent()
        .addUser('Updating user profile')
        .addTransform((session: Session) => {
          // This context will be processed by squashWith
          return session.withVars({
            user: { age: 31, occupation: 'Engineer' }, // Update age, add occupation
            preferences: { notifications: true }, // Overwrite preferences
            status: 'updated', // Add new key
          }) as Session;
        }),
      { squashWith: customSquashWith },
    );

    // Execute the subroutine
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom squashWith function was called
    expect(customSquashWith).toHaveBeenCalled();

    // Verify the messages (only parent messages kept by this squashWith)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(0); // Parent session started empty

    // Verify the deep-merged context according to custom logic
    const user = resultSession.getVar('user');
    expect(user).toEqual({ name: 'Dave', age: 31, occupation: 'Engineer' });

    const preferences = resultSession.getVar('preferences');
    expect(preferences).toEqual({ notifications: true }); // Overwritten

    expect(resultSession.getVar('status')).toBe('updated');
  });

  // New functionality tests for list of templates and method chaining

  it('should support adding multiple templates via method chaining', async () => {
    // Create a subroutine template with method chaining
    const subroutine = new Agent()
      .addSystem('You are a helpful assistant.')
      .addUser('What is your name?')
      .addAssistant('I am an AI assistant.');

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should support adding templates via constructor array', async () => {
    // Create a subroutine template with constructor array
    const subroutine = new Subroutine([
      new System('You are a helpful assistant.'),
      new User('What is your name?'),
      new Assistant('I am an AI assistant.'),
    ]);

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should support nested subroutines with method chaining', async () => {
    // Create an inner subroutine with method chaining
    const innerSubroutine = new Subroutine(
      new Agent()
        .addUser('Inner subroutine question')
        .addAssistant('Inner subroutine answer')
        .addTransform((session: Session<any>) => {
          return session.withVars({ inner: 'completed' });
        }),
    );

    // Create an outer subroutine that includes the inner one via method chaining
    const outerSubroutine = new Subroutine(
      new Agent()
        .addUser('Outer subroutine start')
        .add(innerSubroutine) // Nest the subroutine
        .addUser('Outer subroutine end')
        .addTransform((session: Session<any>) => {
          return session.withVars({ outer: 'completed' });
        }),
    );
    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages (all should be retained by default)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer subroutine start');
    expect(messages[1].content).toBe('Inner subroutine question');
    expect(messages[2].content).toBe('Inner subroutine answer');
    expect(messages[3].content).toBe('Outer subroutine end');

    // Verify the context from both subroutines was merged (default behavior)
    expect(session.getVar('inner')).toBe('completed');
    expect(session.getVar('outer')).toBe('completed');
  });

  it('should support adding subroutines to LinearTemplate (Sequence)', async () => {
    // Create a subroutine
    const nestedSubroutine = new Subroutine(
      new Agent()
        .addUser('Message from nested subroutine')
        .addAssistant('Response from nested subroutine'),
    );

    // Create a sequence that includes the subroutine
    const sequence = new Agent()
      .addSystem('Main sequence system message')
      .add(nestedSubroutine) // Add the subroutine
      .addUser('Message after nested subroutine');

    // Execute the sequence
    const session = await sequence.execute(createSession());

    // Verify the messages from both the sequence and the subroutine are present
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Main sequence system message');
    expect(messages[1].content).toBe('Message from nested subroutine');
    expect(messages[2].content).toBe('Response from nested subroutine');
    expect(messages[3].content).toBe('Message after nested subroutine');
  });

  it('should support adding subroutines to LoopTemplate', async () => {
    // Create a subroutine to be used in the loop body
    const loopSubroutine = new Subroutine(
      new Agent()
        .addUser('Message from loop subroutine')
        .addTransform((session: Session<any>) => {
          return session.withVars({
            // count at the end of agent is 1, 2, 3...
            count: session.getVar('count', 0) + 1,
          });
        }),
    );

    // Create a loop template that includes the subroutine in its body
    const loopTemplate = new Loop({
      bodyTemplate: loopSubroutine, // Use the subroutine as the body
      loopIf: (session: Session<any>) => {
        // Loop if count is 0, 1, or 2
        return (session.getVar('count') || 0) < 2; // Exit when count reaches 2 or more
      },
    });

    // Execute the loop, starting context count at 0
    const session = await loopTemplate.execute(
      createSession({ context: { count: 0 } }),
    );

    // Should have executed the loop body (subroutine) 2 times (exit condition counter >= 2)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(2); // 1 message from subroutine * 2 iterations
    expect(messages[0].content).toBe('Message from loop subroutine');

    // Verify the count was incremented to 2 (executed twice)
    expect(session.getVar('count')).toBe(2);
  });

  it('should work with direct loop implementation', async () => {
    interface CounterContext extends Vars {
      count: number;
    }

    const counterTemplate = new Transform(
      (session: Session<CounterContext>) => {
        const currentCount = session.getVar('count', 0);
        return session.withVars({ count: currentCount + 1 });
      },
    );

    const loop = new Loop({
      bodyTemplate: counterTemplate,
      loopIf: (session: Session<CounterContext>) => {
        // Loop if count is 0, 1, or 2
        return (session.getVar('count') || 0) < 3; // Exit when count reaches 3 or more
      },
    });

    const initialSession = createSession<CounterContext, Attrs>();
    const session = await loop.execute(initialSession);

    // Verify the count was incremented to 3
    expect(session.getVar('count')).toBe(3);
  });

  it('should handle empty templates list gracefully', async () => {
    // Create a subroutine with an empty list of templates
    const subroutine = new Subroutine([]);

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify no messages were added
    expect(session.messages).toHaveLength(0);
  });
});
