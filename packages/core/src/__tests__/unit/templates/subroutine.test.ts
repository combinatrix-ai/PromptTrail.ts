import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createSession } from '../../../session';
import { createGenerateOptions } from '../../../generate_options';
import { createMetadata } from '../../../metadata';
import { generateText } from '../../../generate';
import { Source } from '../../../content_source'; // Import Source
import { SubroutineTemplate, Sequence } from '../../../templates'; // Use correct imports
import type { ISession } from '../../../types'; // Use ISession
import type { Metadata } from '../../../metadata'; // Use Metadata

// Mock the generate module
vi.mock('../../../generate', () => ({
  // Correct path for mock
  generateText: vi.fn(),
}));

describe('SubroutineTemplate', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Set up default mock for generateText
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'Mock response',
      metadata: createMetadata(),
    });
  });

  it('should execute a simple subroutine and merge results by default', async () => {
    // Create a subroutine template with a simple sequence
    const subroutine = new SubroutineTemplate(
      new Sequence()
        .addSystem('You are a helpful assistant.')
        .addUser('What is your name?')
        .addAssistant('I am an AI assistant.'),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages were added
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('You are a helpful assistant.');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('What is your name?');
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('I am an AI assistant.');
  });

  it('should merge metadata generated by the subroutine by default', async () => {
    // Create a subroutine that updates metadata
    const subroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('Extract information')
        .addAssistant('Information extracted')
        .addTransform((session: ISession<any>) => {
          // Add type hint
          // Cast result to satisfy Sequence's transform type expectation
          return session.updateMetadata({
            extractedData: { name: 'Alice', age: 30 },
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the metadata was merged
    expect(session.metadata.get('extractedData')).toEqual({
      name: 'Alice',
      age: 30,
    });
  });

  it('should respect the retainMessages flag', async () => {
    // Create a subroutine with retainMessages = false
    const hideMessagesSubroutine = new SubroutineTemplate(
      new Sequence()
        .addSystem('Internal system message')
        .addUser('Internal user message')
        .addAssistant('Internal assistant message'),
      { retainMessages: false },
    );

    // Execute the subroutine
    const hideMessagesSession =
      await hideMessagesSubroutine.execute(createSession());

    // Verify no messages were retained (default merge logic keeps parent messages)
    const hideMessages = Array.from(hideMessagesSession.messages);
    expect(hideMessages).toHaveLength(0); // Parent session was empty

    // Create a subroutine with retainMessages = true (default)
    const showMessagesSubroutine = new SubroutineTemplate(
      new Sequence()
        .addSystem('Visible system message')
        .addUser('Visible user message')
        .addAssistant('Visible assistant message'),
    );

    // Execute the subroutine
    const showMessagesSession =
      await showMessagesSubroutine.execute(createSession());

    // Verify messages were retained
    const showMessages = Array.from(showMessagesSession.messages);
    expect(showMessages).toHaveLength(3);
  });

  it('should use parent session context by default', async () => {
    // Create a parent session with metadata
    const parentSession = createSession<{ userName: string }>().updateMetadata({
      userName: 'Bob',
    });

    // Add a message to the parent session
    const sessionWithMessage = parentSession.addMessage({
      type: 'system',
      content: 'Parent system message',
    });

    // Create a subroutine that uses parent context (via default initWith)
    // Specify Parent metadata type P
    const subroutine = new SubroutineTemplate<{ userName: string }>( // P = { userName: string }
      new Sequence()
        // Wrap function in a custom Source class
        .addUser(
          new (class extends Source<string> {
            // Accept ISession<any> to match base class, cast metadata internally
            async getContent(session: ISession<any>) {
              return `Hello, ${(session.metadata as Metadata<any>).get('userName')}!`;
            }
          })(),
        )
        .addAssistant('Nice to meet you!'),
    );

    // Execute the subroutine with the parent session
    // sessionWithMessage is ISession<{ userName: string }>, matching subroutine's P type
    const resultSession = await subroutine.execute(sessionWithMessage);

    // Verify the messages (parent + new)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(3);
    expect(messages[0].type).toBe('system');
    expect(messages[0].content).toBe('Parent system message');
    expect(messages[1].type).toBe('user');
    expect(messages[1].content).toBe('Hello, Bob!'); // Interpolated correctly
    expect(messages[2].type).toBe('assistant');
    expect(messages[2].content).toBe('Nice to meet you!');
    // Verify parent metadata is still there
    expect(resultSession.metadata.get('userName')).toBe('Bob');
  });

  it('should allow transformers within the subroutine template', async () => {
    // Mock a more complex response with data to extract
    vi.mocked(generateText).mockResolvedValue({
      type: 'assistant',
      content: 'The weather in Tokyo is 25°C and sunny.',
      metadata: createMetadata(),
    });

    // Create a subroutine with a transformer *inside* the Sequence
    const subroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('What is the weather in Tokyo?')
        .addAssistant(
          createGenerateOptions({
            provider: {
              type: 'openai',
              apiKey: 'test-api-key',
              modelName: 'gpt-4o-mini', // Use latest model
            },
          }),
        )
        // Transformer is part of the inner template's execution
        .addTransform((session: ISession<any>) => {
          // Add type hint
          const lastMessage = session.getLastMessage();
          const content = lastMessage?.content || '';
          const tempMatch = content.match(/(\d+)°C/);
          const temperature = tempMatch ? parseInt(tempMatch[1]) : null;
          const weatherMatch = content.match(/(sunny|cloudy|rainy|snowy)/i);
          const weatherCondition = weatherMatch
            ? weatherMatch[1].toLowerCase()
            : null;
          // Cast result to satisfy Sequence's transform type expectation
          return session.updateMetadata({
            weatherData: {
              location: 'Tokyo',
              temperature,
              condition: weatherCondition,
            },
          }) as ISession<any>;
        }),
    );

    // Execute the subroutine
    const session = await subroutine.execute(createSession());

    // Verify the messages
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(2); // User, Assistant

    // Verify the extracted metadata was merged back
    const weatherData = session.metadata.get('weatherData') as any; // Cast for easier access
    expect(weatherData).toBeDefined();
    expect(weatherData.location).toBe('Tokyo');
    expect(weatherData.temperature).toBe(25);
    expect(weatherData.condition).toBe('sunny');
  });

  it('should handle nested subroutines', async () => {
    // Create an inner subroutine
    const innerSubroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('Inner subroutine question')
        .addAssistant('Inner subroutine answer')
        .addTransform((session: ISession<any>) => {
          // Add type hint
          // Cast result
          return session.updateMetadata({
            inner: 'completed',
          }) as ISession<any>;
        }),
    );

    // Create an outer subroutine that includes the inner one
    const outerSubroutine = new SubroutineTemplate(
      new Sequence()
        .addUser('Outer subroutine start')
        .add(innerSubroutine) // Nest the subroutine
        .addUser('Outer subroutine end')
        .addTransform((session: ISession<any>) => {
          // Add type hint
          // Cast result
          return session.updateMetadata({
            outer: 'completed',
          }) as ISession<any>;
        }),
    );

    // Execute the nested subroutines
    const session = await outerSubroutine.execute(createSession());

    // Verify the messages (all should be retained by default)
    const messages = Array.from(session.messages);
    expect(messages).toHaveLength(4);
    expect(messages[0].content).toBe('Outer subroutine start');
    expect(messages[1].content).toBe('Inner subroutine question');
    expect(messages[2].content).toBe('Inner subroutine answer');
    expect(messages[3].content).toBe('Outer subroutine end');

    // Verify the metadata from both subroutines was merged (default behavior)
    expect(session.metadata.get('inner')).toBe('completed');
    expect(session.metadata.get('outer')).toBe('completed');
  });

  it('should support isolatedContext mode', async () => {
    // Use ISession<any> for parent to allow checking dynamic keys later if needed
    const parentSession = createSession<any>().updateMetadata({
      parentData: 'visible',
    });

    // Create a subroutine with isolatedContext = true
    // Specify Parent metadata type P as any, Subroutine S as any
    const isolatedSubroutine = new SubroutineTemplate<any, any>(
      new Sequence()
        .addUser('Testing isolated context')
        .addTransform((session: ISession<any>) => {
          // Add type hint
          // Try to access parent metadata (should be undefined due to isolated context)
          const parentData = session.metadata.get('parentData');
          // Set new metadata in the isolated context
          // Cast result
          return session.updateMetadata({
            isolatedData: 'not visible to parent',
            parentDataVisible: parentData !== undefined, // This will be false
          }) as ISession<any>;
        }),
      { isolatedContext: true },
    );

    // Execute the subroutine
    // parentSession is ISession<{ parentData: string }>, matching subroutine's P type
    const resultSession = await isolatedSubroutine.execute(parentSession);

    // Verify the parent session received the user message (retainMessages is true by default)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1);
    expect(messages[0].content).toBe('Testing isolated context');

    // The isolatedData should NOT be available in the result due to isolated context
    expect(
      (resultSession.metadata as Metadata<any>).get('isolatedData'),
    ).toBeUndefined(); // Cast to check dynamic key

    // The parentDataVisible metadata (set inside isolated context) should also NOT be merged back
    expect(
      (resultSession.metadata as Metadata<any>).get('parentDataVisible'),
    ).toBeUndefined(); // Cast to check dynamic key

    // Parent metadata should remain unchanged
    expect(resultSession.metadata.get('parentData')).toBe('visible');

    // --- Test shared context (default) ---
    // Specify Parent metadata type P as any, Subroutine S as any
    const sharedSubroutine = new SubroutineTemplate<any, any>(
      new Sequence()
        .addUser('Testing shared context')
        .addTransform((session: ISession<any>) => {
          // Add type hint
          // Try to access parent metadata (should be visible via default initWith)
          const parentData = session.metadata.get('parentData');
          // Set new metadata in the shared context
          // Cast result
          return session.updateMetadata({
            sharedData: 'visible to parent',
            parentDataVisible: parentData !== undefined, // This will be true
          }) as ISession<any>;
        }),
      // { isolatedContext: false } // Default
    );

    // Execute the subroutine
    // parentSession is ISession<{ parentData: string }>, matching subroutine's P type
    const sharedResultSession = await sharedSubroutine.execute(parentSession);

    // The sharedData should be available in the result (merged by default squashWith)
    expect(
      (sharedResultSession.metadata as Metadata<any>).get('sharedData'),
    ).toBe(
      // Cast to check dynamic key
      'visible to parent',
    );

    // The parentDataVisible should be true and merged back
    expect(
      (sharedResultSession.metadata as Metadata<any>).get('parentDataVisible'),
    ).toBe(true); // Cast to check dynamic key

    // Parent metadata should still be there
    expect(sharedResultSession.metadata.get('parentData')).toBe('visible');
  });

  it('should use the initWith function when provided', async () => {
    // Create a custom session initializer function (initWith)
    const customInitWith = vi
      .fn()
      .mockImplementation((parentSession: ISession<any>) => {
        // Use any for parent type in mock
        // Create a new session, selectively copying metadata
        const newSession = createSession<any>(); // Use any for subroutine type S in mock
        const userName = parentSession.metadata.get('userName');
        if (userName) {
          newSession.metadata.set('userName', userName);
        }
        // Add custom initialization metadata
        newSession.metadata.set('customInit', true);
        // Don't copy messages for this test
        return newSession;
      });

    // Create a parent session with various metadata - use any type
    const parentSession = createSession<any>()
      .updateMetadata({ userName: 'Charlie' })
      .updateMetadata({ sensitiveData: 'should not be copied' });

    // Create a subroutine with the custom initWith function
    // Specify Parent type P and Subroutine type S as any
    const subroutine = new SubroutineTemplate<any, any>(
      new Sequence().addUser(
        new (class extends Source<string> {
          // Accept ISession<any> to match base class, cast metadata internally
          async getContent(session: ISession<any>) {
            const userName = (session.metadata as Metadata<any>).get(
              'userName',
            );
            const customInit = (session.metadata as Metadata<any>).get(
              'customInit',
            );
            const sensitiveData = (session.metadata as Metadata<any>).get(
              'sensitiveData',
            ); // Check if undefined
            return `User: ${userName}, Custom: ${customInit}, Sensitive: ${
              sensitiveData === undefined ? 'protected' : 'exposed'
            }`;
          }
        })(),
      ),
      { initWith: customInitWith },
    );

    // Execute the subroutine
    // parentSession matches subroutine's P type
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom initWith function was called
    expect(customInitWith).toHaveBeenCalledWith(parentSession);

    // Verify the message reflects the custom session initialization
    // Messages from parent are not copied due to custom initWith logic
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(1); // Only the addUser message from subroutine
    expect(messages[0].content).toBe(
      'User: Charlie, Custom: true, Sensitive: protected',
    );
    // Verify metadata reflects custom init and default merge (only subroutine metadata added)
    expect(resultSession.metadata.get('userName')).toBe('Charlie'); // From parent via initWith
    expect((resultSession.metadata as Metadata<any>).get('customInit')).toBe(
      true,
    ); // Cast to check dynamic key
    expect(resultSession.metadata.get('sensitiveData')).toBe(
      'should not be copied',
    ); // From parent (default merge)
  });

  it('should use the squashWith function when provided', async () => {
    // Create a parent session with nested metadata
    // Use any type for parent session
    let parentSession = createSession<any>() // Use let
      .updateMetadata({ user: { name: 'Dave', age: 30 } });
    // Assign the result of the second update back to parentSession
    parentSession = parentSession.updateMetadata({
      preferences: { theme: 'dark' },
    });

    // Create a custom merger function (squashWith)
    const customSquashWith = vi
      .fn()
      .mockImplementation(
        (parent: ISession<any>, subroutine: ISession<any>) => {
          // Start with a clone of the parent's metadata object
          const mergedMetadataObject = { ...parent.metadata.toObject() };

          const subroutineMeta = subroutine.metadata.toObject();

          // Deep merge 'user' object
          if (subroutineMeta.user && typeof subroutineMeta.user === 'object') {
            const currentUser = mergedMetadataObject.user || {};
            // Ensure name from parent is kept if not overwritten by subroutine
            mergedMetadataObject.user = {
              ...currentUser,
              ...subroutineMeta.user,
            };
          }

          // Simple overwrite for 'preferences'
          if (subroutineMeta.preferences) {
            mergedMetadataObject.preferences = subroutineMeta.preferences;
          }

          // Add/overwrite any other keys from subroutine
          for (const key in subroutineMeta) {
            if (
              key !== 'user' &&
              key !== 'preferences' &&
              subroutineMeta.hasOwnProperty(key)
            ) {
              mergedMetadataObject[key] = subroutineMeta[key];
            }
          }

          // Create final session - keep parent messages, use merged metadata
          // Create final session - use merged metadata object
          let finalSession = createSession({ metadata: mergedMetadataObject });
          // Add parent messages (as per this test's custom logic)
          parent.messages.forEach(
            (msg) => (finalSession = finalSession.addMessage(msg)),
          );

          // Optionally add subroutine messages if needed (not done in this example)

          return finalSession;
        },
      );

    // Define types for clarity
    // Define types for clarity (though we'll use 'any' in the template instance)
    // type ParentMeta = { user: { name: string; age: number }; preferences: { theme: string } };
    // type SubroutineMeta = { user?: { age?: number; occupation?: string }; preferences?: { notifications?: boolean }; status?: string };

    // Create a subroutine with the custom squashWith function
    // Specify Parent type P and Subroutine type S as any
    const subroutine = new SubroutineTemplate<any, any>(
      new Sequence()
        .addUser('Updating user profile')
        .addTransform((session: ISession<any>) => {
          // Add type hint
          // This metadata will be processed by squashWith
          // Cast result
          return session.updateMetadata({
            user: { age: 31, occupation: 'Engineer' }, // Update age, add occupation
            preferences: { notifications: true }, // Overwrite preferences
            status: 'updated', // Add new key
          }) as ISession<any>;
        }),
      { squashWith: customSquashWith },
    );

    // Execute the subroutine
    // parentSession matches subroutine's P type
    const resultSession = await subroutine.execute(parentSession);

    // Verify the custom squashWith function was called
    expect(customSquashWith).toHaveBeenCalled();

    // Verify the messages (only parent messages kept by this squashWith)
    const messages = Array.from(resultSession.messages);
    expect(messages).toHaveLength(0); // Parent session started empty

    // Verify the deep-merged metadata according to custom logic
    const user = resultSession.metadata.get('user');
    expect(user).toEqual({ name: 'Dave', age: 31, occupation: 'Engineer' });

    const preferences = resultSession.metadata.get('preferences');
    expect(preferences).toEqual({ notifications: true }); // Overwritten

    expect((resultSession.metadata as Metadata<any>).get('status')).toBe(
      'updated',
    ); // Cast to check dynamic key
  });
});
