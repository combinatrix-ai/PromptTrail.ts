// import { describe, it, expect, vi, beforeEach } from 'vitest';
// import { AssistantTemplate } from '../../../templates/assistant';
// import { createSession } from '../../../session';
// import { StaticListSource, StaticSource } from '../../../content_source';
// import { createGenerateOptions } from '../../../generate_options';
// import { createMetadata } from '../../../metadata';
// import { generateText } from '../../../generate';
// import { CustomValidator } from '../../../validators/custom';
// import { createWeatherTool } from '../../utils';
// import { mock } from 'node:test';
// import { SubroutineTemplate } from '@prompttrail/core';
// import { Sequence } from '../../../templates';
// // Mock the generate module
// vi.mock('../../generate', () => ({
//   generateText: vi.fn(),
// }));

// describe('SubroutineTemplate', () => {
//   beforeEach(() => {
//     vi.resetAllMocks();
    
//     // Set up default mock for generateText
//     vi.mocked(generateText).mockResolvedValue({
//       type: 'assistant',
//       content: 'Mock response',
//       metadata: createMetadata(),
//     });
//   });

//   it('should execute a simple subroutine and merge results', async () => {
//     // Create a subroutine template with a simple sequence
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addSystem('You are a helpful assistant.')
//         .addUser('What is your name?')
//         .addAssistant('I am an AI assistant.')
//     );
    
//     // Execute the subroutine
//     const session = await subroutine.execute(createSession());
    
//     // Verify the messages were added
//     const messages = Array.from(session.messages);
//     expect(messages).toHaveLength(3);
//     expect(messages[0].type).toBe('system');
//     expect(messages[0].content).toBe('You are a helpful assistant.');
//     expect(messages[1].type).toBe('user');
//     expect(messages[1].content).toBe('What is your name?');
//     expect(messages[2].type).toBe('assistant');
//     expect(messages[2].content).toBe('I am an AI assistant.');
//   });

//   it('should merge metadata generated by the subroutine', async () => {
//     // Create a subroutine that updates metadata
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('Extract information')
//         .addAssistant('Information extracted')
//         .addTransform((session) => {
//           return session.updateMetadata({
//             extractedData: { name: 'Alice', age: 30 }
//           });
//         })
//     );
    
//     // Execute the subroutine
//     const session = await subroutine.execute(createSession());
    
//     // Verify the metadata was merged
//     expect(session.metadata.get('extractedData')).toEqual({ name: 'Alice', age: 30 });
//   });

//   it('should respect the retainMessages flag', async () => {
//     // Create a subroutine with retainMessages = false
//     const hideMessagesSubroutine = new SubroutineTemplate(
//       new Sequence()
//         .addSystem('Internal system message')
//         .addUser('Internal user message')
//         .addAssistant('Internal assistant message'),
//       { retainMessages: false }
//     );
    
//     // Execute the subroutine
//     const hideMessagesSession = await hideMessagesSubroutine.execute(createSession());
    
//     // Verify no messages were retained
//     const hideMessages = Array.from(hideMessagesSession.messages);
//     expect(hideMessages).toHaveLength(0);
    
//     // Create a subroutine with retainMessages = true (default)
//     const showMessagesSubroutine = new SubroutineTemplate(
//       new Sequence()
//         .addSystem('Visible system message')
//         .addUser('Visible user message')
//         .addAssistant('Visible assistant message')
//     );
    
//     // Execute the subroutine
//     const showMessagesSession = await showMessagesSubroutine.execute(createSession());
    
//     // Verify messages were retained
//     const showMessages = Array.from(showMessagesSession.messages);
//     expect(showMessages).toHaveLength(3);
//   });

//   it('should work with a parent session context', async () => {
//     // Create a parent session with metadata
//     const parentSession = createSession();
//     parentSession.metadata.set('userName', 'Bob');
    
//     // Add a message to the parent session
//     const sessionWithMessage = parentSession.addMessage({
//       type: 'system',
//       content: 'Parent system message',
//       metadata: createMetadata(),
//     });
    
//     // Create a subroutine that uses parent context
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser((session) => `Hello, ${session.metadata.get('userName')}!`)
//         .addAssistant('Nice to meet you!')
//     );
    
//     // Execute the subroutine with the parent session
//     const resultSession = await subroutine.execute(sessionWithMessage);
    
//     // Verify the messages
//     const messages = Array.from(resultSession.messages);
//     expect(messages).toHaveLength(3);
//     expect(messages[0].type).toBe('system');
//     expect(messages[0].content).toBe('Parent system message');
//     expect(messages[1].type).toBe('user');
//     expect(messages[1].content).toBe('Hello, Bob!');
//     expect(messages[2].type).toBe('assistant');
//     expect(messages[2].content).toBe('Nice to meet you!');
//   });

//   it('should allow custom transformers to process subroutine outputs', async () => {
//     // Mock a more complex response with data to extract
//     vi.mocked(generateText).mockResolvedValue({
//       type: 'assistant',
//       content: 'The weather in Tokyo is 25°C and sunny.',
//       metadata: createMetadata(),
//     });
    
//     // Create a subroutine with a transformer
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('What is the weather in Tokyo?')
//         .addAssistant(createGenerateOptions({
//           provider: {
//             type: 'openai',
//             apiKey: 'test-api-key',
//             modelName: 'gpt-4',
//           },
//         })),
//       {
//         transform: (session) => {
//           // Extract weather data from the last message
//           const lastMessage = session.getLastMessage();
//           const content = lastMessage?.content || '';
          
//           // Simple extraction
//           const tempMatch = content.match(/(\d+)°C/);
//           const temperature = tempMatch ? parseInt(tempMatch[1]) : null;
          
//           const weatherMatch = content.match(/(sunny|cloudy|rainy|snowy)/i);
//           const weatherCondition = weatherMatch ? weatherMatch[1].toLowerCase() : null;
          
//           // Update metadata with extracted information
//           return session.updateMetadata({
//             weatherData: {
//               location: 'Tokyo',
//               temperature,
//               condition: weatherCondition
//             }
//           });
//         }
//       }
//     );
    
//     // Execute the subroutine
//     const session = await subroutine.execute(createSession());
    
//     // Verify the messages
//     const messages = Array.from(session.messages);
//     expect(messages).toHaveLength(2);
    
//     // Verify the extracted metadata
//     const weatherData = session.metadata.get('weatherData');
//     expect(weatherData).toBeDefined();
//     expect(weatherData.location).toBe('Tokyo');
//     expect(weatherData.temperature).toBe(25);
//     expect(weatherData.condition).toBe('sunny');
//   });

//   it('should handle nested subroutines', async () => {
//     // Create an inner subroutine
//     const innerSubroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('Inner subroutine question')
//         .addAssistant('Inner subroutine answer')
//         .addTransform((session) => {
//           return session.updateMetadata({ inner: 'completed' });
//         })
//     );
    
//     // Create an outer subroutine that includes the inner one
//     const outerSubroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('Outer subroutine start')
//         .add(innerSubroutine)
//         .addUser('Outer subroutine end')
//         .addTransform((session) => {
//           return session.updateMetadata({ outer: 'completed' });
//         })
//     );
    
//     // Execute the nested subroutines
//     const session = await outerSubroutine.execute(createSession());
    
//     // Verify the messages
//     const messages = Array.from(session.messages);
//     expect(messages).toHaveLength(4);
//     expect(messages[0].content).toBe('Outer subroutine start');
//     expect(messages[1].content).toBe('Inner subroutine question');
//     expect(messages[2].content).toBe('Inner subroutine answer');
//     expect(messages[3].content).toBe('Outer subroutine end');
    
//     // Verify the metadata from both subroutines was merged
//     expect(session.metadata.get('inner')).toBe('completed');
//     expect(session.metadata.get('outer')).toBe('completed');
//   });

//   it('should support isolatedContext mode', async () => {
//     // Create a parent session with metadata
//     const parentSession = createSession();
//     parentSession.metadata.set('parentData', 'visible');
    
//     // Create a subroutine with isolatedContext = true
//     const isolatedSubroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('Testing isolated context')
//         .addTransform((session) => {
//           // Try to access parent metadata (should be undefined)
//           const parentData = session.metadata.get('parentData');
          
//           // Set new metadata in the isolated context
//           return session.updateMetadata({
//             isolatedData: 'not visible to parent',
//             parentDataVisible: parentData !== undefined
//           });
//         }),
//       { isolatedContext: true }
//     );
    
//     // Execute the subroutine
//     const resultSession = await isolatedSubroutine.execute(parentSession);
    
//     // Verify the parent session received the user message
//     const messages = Array.from(resultSession.messages);
//     expect(messages).toHaveLength(1);
//     expect(messages[0].content).toBe('Testing isolated context');
    
//     // The isolatedData should not be available in the result
//     expect(resultSession.metadata.get('isolatedData')).toBeUndefined();
    
//     // The parentDataVisible should be false since parent context wasn't available
//     expect(resultSession.metadata.get('parentDataVisible')).toBe(false);
    
//     // Create a subroutine with isolatedContext = false (default)
//     const sharedSubroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('Testing shared context')
//         .addTransform((session) => {
//           // Try to access parent metadata (should be visible)
//           const parentData = session.metadata.get('parentData');
          
//           // Set new metadata in the shared context
//           return session.updateMetadata({
//             sharedData: 'visible to parent',
//             parentDataVisible: parentData !== undefined
//           });
//         })
//     );
    
//     // Execute the subroutine
//     const sharedResultSession = await sharedSubroutine.execute(parentSession);
    
//     // The sharedData should be available in the result
//     expect(sharedResultSession.metadata.get('sharedData')).toBe('visible to parent');
    
//     // The parentDataVisible should be true since parent context was available
//     expect(sharedResultSession.metadata.get('parentDataVisible')).toBe(true);
//   });

//   it('should use the customSessionFactory when provided', async () => {
//     // Create a custom session factory function
//     const customSessionFactory = vi.fn().mockImplementation((parentSession) => {
//       const newSession = createSession();
//       // Copy specific metadata from parent
//       if (parentSession) {
//         const allowedKeys = ['userName'];
//         for (const key of allowedKeys) {
//           const value = parentSession.metadata.get(key);
//           if (value !== undefined) {
//             newSession.metadata.set(key, value);
//           }
//         }
//       }
//       // Add custom initialization
//       newSession.metadata.set('customInit', true);
//       return newSession;
//     });
    
//     // Create a parent session with various metadata
//     const parentSession = createSession();
//     parentSession.metadata.set('userName', 'Charlie');
//     parentSession.metadata.set('sensitiveData', 'should not be copied');
    
//     // Create a subroutine with the custom session factory
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser((session) => {
//           const userName = session.metadata.get('userName');
//           const customInit = session.metadata.get('customInit');
//           const sensitiveData = session.metadata.get('sensitiveData');
//           return `User: ${userName}, Custom: ${customInit}, Sensitive: ${sensitiveData === undefined ? 'protected' : 'exposed'}`;
//         }),
//       { sessionFactory: customSessionFactory }
//     );
    
//     // Execute the subroutine
//     const resultSession = await subroutine.execute(parentSession);
    
//     // Verify the custom session factory was called
//     expect(customSessionFactory).toHaveBeenCalledWith(parentSession);
    
//     // Verify the message reflects the custom session initialization
//     const messages = Array.from(resultSession.messages);
//     expect(messages).toHaveLength(1);
//     expect(messages[0].content).toBe('User: Charlie, Custom: true, Sensitive: protected');
//   });

//   it('should allow metadata merging strategies', async () => {
//     // Create a parent session with nested metadata
//     const parentSession = createSession();
//     parentSession.metadata.set('user', { name: 'Dave', age: 30 });
//     parentSession.metadata.set('preferences', { theme: 'dark' });
    
//     // Create a custom merger that updates nested objects properly
//     const deepMerger = (parentMetadata: any, subroutineMetadata: any) => {
//       const merged = { ...parentMetadata };
      
//       for (const [key, value] of Object.entries(subroutineMetadata)) {
//         if (
//           key in merged &&
//           typeof merged[key] === 'object' && 
//           typeof value === 'object'
//         ) {
//           // Deep merge for objects
//           merged[key] = { ...merged[key], ...value };
//         } else {
//           // Simple override for non-objects or new keys
//           merged[key] = value;
//         }
//       }
      
//       return merged;
//     };
    
//     // Create a subroutine with the custom merger
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('Updating user profile')
//         .addTransform((session) => {
//           return session.updateMetadata({
//             user: { age: 31, occupation: 'Engineer' }, // Update age, add occupation
//             preferences: { notifications: true } // Add new pref while keeping theme
//           });
//         }),
//       { metadataMerger: deepMerger }
//     );
    
//     // Execute the subroutine
//     const resultSession = await subroutine.execute(parentSession);
    
//     // Verify the message
//     const messages = Array.from(resultSession.messages);
//     expect(messages).toHaveLength(1);
    
//     // Verify the deep-merged metadata
//     const user = resultSession.metadata.get('user');
//     expect(user).toEqual({ name: 'Dave', age: 31, occupation: 'Engineer' });
    
//     const preferences = resultSession.metadata.get('preferences');
//     expect(preferences).toEqual({ theme: 'dark', notifications: true });
//   });

//   it('should format the output appropriately with formatOutput option', async () => {
//     // Define a custom output formatter
//     const outputFormatter = (subroutineSession: Session) => {
//       // Get the last assistant message
//       const assistantMessages = subroutineSession.getMessagesByType('assistant');
//       const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
      
//       // Extract relevant information
//       const content = lastAssistantMessage?.content || '';
      
//       // Format as a structured result
//       return {
//         answer: content,
//         timestamp: new Date().toISOString(),
//         messageCount: subroutineSession.messages.length
//       };
//     };
    
//     // Create a subroutine with the output formatter
//     const subroutine = new SubroutineTemplate(
//       new Sequence()
//         .addUser('What is the capital of France?')
//         .addAssistant('The capital of France is Paris.'),
//       { formatOutput: outputFormatter }
//     );
    
//     // Execute the subroutine
//     const resultSession = await subroutine.execute(createSession());
    
//     // Verify the messages
//     const messages = Array.from(resultSession.messages);
//     expect(messages).toHaveLength(2);
    
//     // Verify the formatted output is in the metadata
//     const result = resultSession.metadata.get('subroutineResult');
//     expect(result).toBeDefined();
//     expect(result.answer).toBe('The capital of France is Paris.');
//     expect(result.messageCount).toBe(2);
//     expect(typeof result.timestamp).toBe('string');
//   });
// });
