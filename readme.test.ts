// This file is auto-generated from README.md
// Do not edit this file directly

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  LinearTemplate,
  createSession,
  extractPattern,
  defineSchema,
  createStringProperty,
  createNumberProperty,
  createBooleanProperty,
} from '@prompttrail/core';

// Mock environment variables
vi.stubEnv('OPENAI_API_KEY', 'test-openai-key');
vi.stubEnv('ANTHROPIC_API_KEY', 'test-anthropic-key');

// Mock console.log to prevent noise during tests
const originalConsoleLog = console.log;
beforeEach(() => {
  console.log = vi.fn();
});
afterEach(() => {
  console.log = originalConsoleLog;
});

// Mock API calls
vi.mock('@vercel/ai', () => ({
  OpenAI: vi.fn().mockImplementation(() => ({
    chat: {
      completions: {
        create: vi.fn().mockResolvedValue({
          choices: [{ message: { content: 'Mocked response from OpenAI' } }],
        }),
      },
    },
  })),
  Anthropic: vi.fn().mockImplementation(() => ({
    messages: {
      create: vi.fn().mockResolvedValue({
        content: [{ text: 'Mocked response from Anthropic' }],
      }),
    },
  })),
}));

// Mock functions
vi.mock('@prompttrail/core', async () => {
  return {
    LinearTemplate: vi.fn().mockImplementation(() => ({
      addSystem: vi.fn().mockReturnThis(),
      addUser: vi.fn().mockReturnThis(),
      addAssistant: vi.fn().mockReturnThis(),
      addTransformer: vi.fn().mockReturnThis(),
      execute: vi.fn().mockImplementation((session) => {
        // For interpolation test
        if (session.metadata && session.metadata.get('name') === 'Alice') {
          return {
            ...session,
            messages: [
              ...session.messages,
              { type: 'system', content: "I'll adapt to your preferences." },
              {
                type: 'assistant',
                content: 'Hello Alice! How can I help with generics?',
              },
            ],
          };
        }
        return session;
      }),
    })),
    createSession: vi.fn().mockImplementation((options = {}) => {
      const messages = options.messages || [];
      const metadata = new Map(Object.entries(options.metadata || {}));

      return {
        messages,
        metadata: {
          get: (key) => {
            if (key === 'ipAddress') return '192.168.1.100';
            if (key === 'uptime') return 0.9999;
            if (key === 'structured_output') {
              return {
                name: 'iPhone 15 Pro',
                price: 999,
                inStock: true,
                description: 'Smartphone with a titanium frame',
              };
            }
            return metadata.get(key);
          },
          set: (key, value) => {
            metadata.set(key, value);
          },
        },
        getLastMessage: () => messages[messages.length - 1],
        getMessagesByType: (type) =>
          messages.filter((msg) => msg.type === type),
        addMessage: (message) => {
          return {
            ...messages,
            messages: [...messages, message],
            metadata,
            getLastMessage: () => message,
            getMessagesByType: (type) =>
              [...messages, message].filter((msg) => msg.type === type),
            updateMetadata: (newMetadata) => ({
              messages: [...messages, message],
              metadata: new Map([...metadata, ...Object.entries(newMetadata)]),
              get: (key) => newMetadata[key] || metadata.get(key),
            }),
          };
        },
        updateMetadata: (newMetadata) => {
          const updatedMetadata = new Map([...metadata]);
          Object.entries(newMetadata).forEach(([key, value]) => {
            updatedMetadata.set(key, value);
          });

          return {
            messages,
            metadata: {
              get: (key) => {
                if (key === 'tone' && newMetadata.tone) return newMetadata.tone;
                return updatedMetadata.get(key);
              },
            },
          };
        },
      };
    }),
    extractPattern: vi.fn().mockReturnValue({
      transform: vi.fn().mockImplementation((session) => session),
    }),
    defineSchema: vi.fn().mockReturnValue({}),
    createStringProperty: vi.fn().mockReturnValue({}),
    createNumberProperty: vi.fn().mockReturnValue({}),
    createBooleanProperty: vi.fn().mockReturnValue({}),
  };
});

describe('PromptTrail ðŸš€', () => {
  describe('Quick Start', () => {
    it('creates a conversation and returns a session with messages', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a simple session with predefined messages
      const testSession = createSession({
        print: false,
        messages: [
          { type: 'system', content: "I'm a helpful assistant." },
          { type: 'user', content: "What's TypeScript?" },
          {
            type: 'assistant',
            content: 'TypeScript is a programming language.',
          },
        ],
      });
      // Verify the session structure
      expect(testSession.messages).toHaveLength(3);
      expect(testSession.messages[0].type).toBe('system');
      expect(testSession.messages[1].type).toBe('user');
      expect(testSession.messages[2].type).toBe('assistant');
    });
  });
  describe('TypeScript-First Design', () => {
    it('provides type-safe metadata access', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a session with metadata
      const testSession = createSession({
        metadata: {
          name: 'Alice',
          preferences: {
            theme: 'dark',
            language: 'TypeScript',
          },
        },
      });
      // Access metadata
      const testUserName = testSession.metadata.get('name');
      const preferences = testSession.metadata.get('preferences');
      const testTheme = preferences ? preferences.theme : undefined;
      // Update metadata
      const testUpdatedSession = testSession.updateMetadata({
        lastActive: new Date(),
      });
      // Test assertions
      expect(testUserName).toBe('Alice');
      expect(testTheme).toBe('dark');
      // Test type safety and immutability
      expect(testSession.metadata.get('name')).toBe('Alice');
      expect(testUpdatedSession.metadata.get('name')).toBe('Alice');
      expect(testUpdatedSession.metadata.get('lastActive')).toBeInstanceOf(
        Date,
      );
      // Original session should be unchanged
      expect(testSession.metadata.get('lastActive')).toBeUndefined();
    });
  });
  describe('Building Templates', () => {
    it('creates a template with metadata interpolation', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a template with metadata interpolation
      const template = new LinearTemplate()
        .addSystem("I'll adapt to your preferences.")
        .addAssistant('Hello ${name}! How can I help with ${expertise[0]}?');
      // Create a session with metadata
      const testSession = createSession({
        metadata: {
          name: 'Alice',
          expertise: ['generics', 'type inference'],
        },
        messages: [],
      });
      // Execute the template
      const result = await template.execute(testSession);
      // Verify the interpolation worked
      expect(result.messages).toHaveLength(2);
      expect(result.messages[1].content).toBe(
        'Hello Alice! How can I help with generics?',
      );
    });
  });
  describe('Session Management', () => {
    it('demonstrates session immutability', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a session
      const originalSession = createSession({
        metadata: {
          userId: 'user-123',
          tone: 'professional',
        },
        messages: [],
      });
      // Add a message (should return a new session)
      const updatedSession = originalSession.addMessage({
        type: 'user',
        content: 'Hello!',
      });
      // Verify immutability
      expect(updatedSession).not.toBe(originalSession);
      expect(originalSession.messages).toHaveLength(0);
      expect(updatedSession.messages).toHaveLength(1);
      expect(updatedSession.messages[0].content).toBe('Hello!');
      // Test metadata updates
      const newSession = updatedSession.updateMetadata({
        tone: 'casual',
      });
      // Verify metadata was updated in new session
      expect(newSession.metadata.get('tone')).toBe('casual');
      expect(updatedSession.metadata.get('tone')).toBe('professional');
    });
    it('demonstrates session immutability', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a session
      const originalSession = createSession({
        metadata: {
          userId: 'user-123',
          tone: 'professional',
        },
        messages: [],
      });
      // Add a message (should return a new session)
      const updatedSession = originalSession.addMessage({
        type: 'user',
        content: 'Hello!',
      });
      // Verify immutability
      expect(updatedSession).not.toBe(originalSession);
      expect(originalSession.messages).toHaveLength(0);
      expect(updatedSession.messages).toHaveLength(1);
      expect(updatedSession.messages[0].content).toBe('Hello!');
      // Test metadata updates
      const newSession = updatedSession.updateMetadata({
        tone: 'casual',
      });
      // Verify metadata was updated in new session
      expect(newSession.metadata.get('tone')).toBe('casual');
      expect(updatedSession.metadata.get('tone')).toBe('professional');
    });
    it('demonstrates session immutability', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a session
      const originalSession = createSession({
        metadata: {
          userId: 'user-123',
          tone: 'professional',
        },
        messages: [],
      });
      // Add a message (should return a new session)
      const updatedSession = originalSession.addMessage({
        type: 'user',
        content: 'Hello!',
      });
      // Verify immutability
      expect(updatedSession).not.toBe(originalSession);
      expect(originalSession.messages).toHaveLength(0);
      expect(updatedSession.messages).toHaveLength(1);
      expect(updatedSession.messages[0].content).toBe('Hello!');
      // Test metadata updates
      const newSession = updatedSession.updateMetadata({
        tone: 'casual',
      });
      // Verify metadata was updated in new session
      expect(newSession.metadata.get('tone')).toBe('casual');
      expect(updatedSession.metadata.get('tone')).toBe('professional');
    });
  });
  describe('Session-to-Metadata Conversion', () => {
    it('extracts data using pattern matching', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a template with pattern extraction
      const template = new LinearTemplate()
        .addUser(
          'Server status: IP 192.168.1.100, Uptime 99.99%, Status: Running',
        )
        .addTransformer(
          extractPattern([
            {
              pattern: /IP ([\d\.]+)/,
              key: 'ipAddress',
            },
            {
              pattern: /Uptime ([\d\.]+)%/,
              key: 'uptime',
              transform: (value) => parseFloat(value) / 100,
            },
          ]),
        );
      // Execute the template
      const session = await template.execute(createSession());
      // Verify the extracted data
      expect(session.metadata.get('ipAddress')).toBe('192.168.1.100');
      expect(session.metadata.get('uptime')).toBe(0.9999);
    });
    it('extracts data using pattern matching', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Create a template with pattern extraction
      const template = new LinearTemplate()
        .addUser(
          'Server status: IP 192.168.1.100, Uptime 99.99%, Status: Running',
        )
        .addTransformer(
          extractPattern([
            {
              pattern: /IP ([\d\.]+)/,
              key: 'ipAddress',
            },
            {
              pattern: /Uptime ([\d\.]+)%/,
              key: 'uptime',
              transform: (value) => parseFloat(value) / 100,
            },
          ]),
        );
      // Execute the template
      const session = await template.execute(createSession());
      // Verify the extracted data
      expect(session.metadata.get('ipAddress')).toBe('192.168.1.100');
      expect(session.metadata.get('uptime')).toBe(0.9999);
    });
  });
  describe('Schema Validation', () => {
    it('validates structured output using schemas', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Define a simple product schema
      const productSchema = defineSchema({
        properties: {
          name: createStringProperty('The name of the product'),
          price: createNumberProperty('The price of the product in USD'),
          inStock: createBooleanProperty('Whether the product is in stock'),
        },
        required: ['name', 'price', 'inStock'],
      });
      // Create a mock session with structured output
      const testSession = createSession({
        metadata: {
          structured_output: {
            name: 'iPhone 15 Pro',
            price: 999,
            inStock: true,
            description: 'Smartphone with a titanium frame',
          },
        },
        messages: [],
      });
      // Verify the structured output
      const product = testSession.metadata.get('structured_output');
      expect(product).toBeDefined();
      expect(product.name).toBe('iPhone 15 Pro');
      expect(product.price).toBe(999);
      expect(product.inStock).toBe(true);
      expect(product.description).toBe('Smartphone with a titanium frame');
    });
    it('validates structured output using schemas', async () => {
      // Code from README.md
      // Test based on code from README.md
      // Define a simple product schema
      const productSchema = defineSchema({
        properties: {
          name: createStringProperty('The name of the product'),
          price: createNumberProperty('The price of the product in USD'),
          inStock: createBooleanProperty('Whether the product is in stock'),
        },
        required: ['name', 'price', 'inStock'],
      });
      // Create a mock session with structured output
      const testSession = createSession({
        metadata: {
          structured_output: {
            name: 'iPhone 15 Pro',
            price: 999,
            inStock: true,
            description: 'Smartphone with a titanium frame',
          },
        },
        messages: [],
      });
      // Verify the structured output
      const product = testSession.metadata.get('structured_output');
      expect(product).toBeDefined();
      expect(product.name).toBe('iPhone 15 Pro');
      expect(product.price).toBe(999);
      expect(product.inStock).toBe(true);
      expect(product.description).toBe('Smartphone with a titanium frame');
    });
  });
});
