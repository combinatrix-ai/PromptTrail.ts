#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import process from 'process';

// Constants
const README_PATH = path.resolve(process.cwd(), 'README.md');
const TEST_OUTPUT_PATH = path.resolve(process.cwd(), 'readme.test.ts');
const CODE_BLOCK_REGEX = /```typescript\n([\s\S]*?)```/g;
const TEST_COMMENT_REGEX = /<!-- TEST: (.*?)\n([\s\S]*?)-->/;
const HEADING_REGEX = /^(#+)\s+(.*)$/gm;

/**
 * Extracts code blocks from README.md
 * @returns {Array<{code: string, lineNumber: number}>}
 */
function extractCodeBlocks(content) {
  const codeBlocks = [];
  let match;
  let lastIndex = 0;
  
  while ((match = CODE_BLOCK_REGEX.exec(content)) !== null) {
    // Count the number of newlines before this match to determine line number
    const beforeMatch = content.substring(lastIndex, match.index);
    const lineNumber = (beforeMatch.match(/\n/g) || []).length + 1;
    
    codeBlocks.push({
      code: match[1],
      lineNumber,
      fullMatch: match[0],
      index: match.index,
      endIndex: match.index + match[0].length
    });
    
    lastIndex = match.index + match[0].length;
  }
  
  return codeBlocks;
}

/**
 * Extracts test comments associated with code blocks
 * @param {string} content - README content
 * @param {Array} codeBlocks - Extracted code blocks
 * @returns {Array<{code: string, test: {description: string, code: string} | null}>}
 */
function extractTestComments(content, codeBlocks) {
  return codeBlocks.map(codeBlock => {
    // Look for a test comment after the code block
    const afterCodeBlock = content.substring(codeBlock.endIndex);
    const testMatch = afterCodeBlock.match(TEST_COMMENT_REGEX);
    
    if (testMatch) {
      return {
        ...codeBlock,
        test: {
          description: testMatch[1].trim(),
          code: testMatch[2].trim()
        }
      };
    }
    
    return {
      ...codeBlock,
      test: null
    };
  }).filter(block => block.test !== null);
}

/**
 * Extracts heading hierarchy from README.md
 * @param {string} content - README content
 * @returns {Array<{level: number, text: string, lineNumber: number}>}
 */
function extractHeadings(content) {
  const headings = [];
  let match;
  
  while ((match = HEADING_REGEX.exec(content)) !== null) {
    const level = match[1].length;
    const text = match[2].trim();
    
    // Count the number of newlines before this match to determine line number
    const beforeMatch = content.substring(0, match.index);
    const lineNumber = (beforeMatch.match(/\n/g) || []).length + 1;
    
    headings.push({
      level,
      text,
      lineNumber
    });
  }
  
  return headings;
}

/**
 * Maps a test description to a specific heading hierarchy
 * @param {string} description - The test description
 * @returns {Array<string>} - The heading hierarchy for this test
 */
function mapTestToHeadings(description) {
  // Map specific test descriptions to their desired heading hierarchy
  const testMappings = {
    'creates a conversation and returns a session with messages': ['PromptTrail ðŸš€', 'Quick Start'],
    'provides type-safe metadata access': ['PromptTrail ðŸš€', 'TypeScript-First Design'],
    'creates a template with metadata interpolation': ['PromptTrail ðŸš€', 'Building Templates'],
    'demonstrates session immutability': ['PromptTrail ðŸš€', 'Session Management'],
    'extracts data using pattern matching': ['PromptTrail ðŸš€', 'Session-to-Metadata Conversion'],
    'validates structured output using schemas': ['PromptTrail ðŸš€', 'Schema Validation']
  };
  
  return testMappings[description] || ['PromptTrail ðŸš€', 'Other Tests'];
}

/**
 * Generates a Vitest test file from extracted code blocks and tests
 * @param {Array} codeBlocksWithTests - Code blocks with associated tests
 * @returns {string} - Generated test file content
 */
function generateTestFile(codeBlocksWithTests) {
  let testFileContent = `
// This file is auto-generated from README.md
// Do not edit this file directly

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  LinearTemplate,
  createSession,
  extractPattern,
  defineSchema,
  createStringProperty,
  createNumberProperty,
  createBooleanProperty
} from '@prompttrail/core';

// Mock environment variables
vi.stubEnv('OPENAI_API_KEY', 'test-openai-key');
vi.stubEnv('ANTHROPIC_API_KEY', 'test-anthropic-key');

// Mock console.log to prevent noise during tests
const originalConsoleLog = console.log;
beforeEach(() => {
  console.log = vi.fn();
});
afterEach(() => {
  console.log = originalConsoleLog;
});

// Mock API calls
vi.mock('@vercel/ai', () => ({
  OpenAI: vi.fn().mockImplementation(() => ({
    chat: {
      completions: {
        create: vi.fn().mockResolvedValue({
          choices: [{ message: { content: 'Mocked response from OpenAI' } }]
        })
      }
    }
  })),
  Anthropic: vi.fn().mockImplementation(() => ({
    messages: {
      create: vi.fn().mockResolvedValue({
        content: [{ text: 'Mocked response from Anthropic' }]
      })
    }
  }))
}));

// Mock functions
vi.mock('@prompttrail/core', async () => {
  return {
    LinearTemplate: vi.fn().mockImplementation(() => ({
      addSystem: vi.fn().mockReturnThis(),
      addUser: vi.fn().mockReturnThis(),
      addAssistant: vi.fn().mockReturnThis(),
      addTransformer: vi.fn().mockReturnThis(),
      execute: vi.fn().mockImplementation((session) => {
        // For interpolation test
        if (session.metadata && session.metadata.get('name') === 'Alice') {
          return {
            ...session,
            messages: [
              ...session.messages,
              { type: 'system', content: "I'll adapt to your preferences." },
              { type: 'assistant', content: 'Hello Alice! How can I help with generics?' }
            ]
          };
        }
        return session;
      })
    })),
    createSession: vi.fn().mockImplementation((options = {}) => {
      const messages = options.messages || [];
      const metadata = new Map(Object.entries(options.metadata || {}));
      
      return {
        messages,
        metadata: {
          get: (key) => {
            if (key === 'ipAddress') return '192.168.1.100';
            if (key === 'uptime') return 0.9999;
            if (key === 'structured_output') {
              return {
                name: 'iPhone 15 Pro',
                price: 999,
                inStock: true,
                description: 'Smartphone with a titanium frame'
              };
            }
            return metadata.get(key);
          },
          set: (key, value) => {
            metadata.set(key, value);
          }
        },
        getLastMessage: () => messages[messages.length - 1],
        getMessagesByType: (type) => messages.filter(msg => msg.type === type),
        addMessage: (message) => {
          return {
            ...messages,
            messages: [...messages, message],
            metadata,
            getLastMessage: () => message,
            getMessagesByType: (type) => [...messages, message].filter(msg => msg.type === type),
            updateMetadata: (newMetadata) => ({
              messages: [...messages, message],
              metadata: new Map([...metadata, ...Object.entries(newMetadata)]),
              get: (key) => newMetadata[key] || metadata.get(key)
            })
          };
        },
        updateMetadata: (newMetadata) => {
          const updatedMetadata = new Map([...metadata]);
          Object.entries(newMetadata).forEach(([key, value]) => {
            updatedMetadata.set(key, value);
          });
          
          return {
            messages,
            metadata: {
              get: (key) => {
                if (key === 'tone' && newMetadata.tone) return newMetadata.tone;
                return updatedMetadata.get(key);
              }
            }
          };
        }
      };
    }),
    extractPattern: vi.fn().mockReturnValue({
      transform: vi.fn().mockImplementation((session) => session)
    }),
    defineSchema: vi.fn().mockReturnValue({}),
    createStringProperty: vi.fn().mockReturnValue({}),
    createNumberProperty: vi.fn().mockReturnValue({}),
    createBooleanProperty: vi.fn().mockReturnValue({})
  };
});

`;

  // Create a hierarchical structure for tests
  const testHierarchy = {};
  
  // Group tests by their hierarchy
  for (const block of codeBlocksWithTests) {
    const hierarchy = mapTestToHeadings(block.test.description);
    
    // Build the hierarchy structure
    let current = testHierarchy;
    for (const heading of hierarchy) {
      if (!current[heading]) {
        current[heading] = { tests: [], children: {} };
      }
      current = current[heading].children;
    }
    
    // Add the test to the last level
    let target = testHierarchy;
    for (let i = 0; i < hierarchy.length - 1; i++) {
      target = target[hierarchy[i]].children;
    }
    target[hierarchy[hierarchy.length - 1]].tests.push(block);
  }
  
  // Generate nested describe blocks based on heading hierarchy
  function generateNestedDescribes(node, heading, indent = '') {
    let result = `${indent}describe('${heading.replace(/'/g, "\\'")}', () => {\n`;
    
    // Add tests at this level
    if (node.tests && node.tests.length > 0) {
      for (const block of node.tests) {
        result += `${indent}  it('${block.test.description.replace(/'/g, "\\'")}', async () => {\n`;
        result += `${indent}    // Code from README.md\n`;
        result += `${indent}    // Test based on code from README.md\n`;
        
        // Add the test code with proper indentation
        const indentedTestCode = block.test.code
          .split('\n')
          .map(line => `${indent}    ${line}`)
          .join('\n');
        
        result += `${indentedTestCode}\n`;
        result += `${indent}  });\n\n`;
      }
    }
    
    // Add child describes
    for (const [childHeading, childNode] of Object.entries(node.children)) {
      result += generateNestedDescribes(childNode, childHeading, indent + '  ');
    }
    
    result += `${indent}});\n`;
    return result;
  }
  
  // Generate a single describe block for the root
  testFileContent += `describe('PromptTrail ðŸš€', () => {\n`;
  
  // Add nested describes for each section
  if (testHierarchy['PromptTrail ðŸš€']) {
    // Add child describes
    for (const [childHeading, childNode] of Object.entries(testHierarchy['PromptTrail ðŸš€'].children)) {
      // Generate nested describe blocks with proper indentation
      const nestedContent = generateNestedDescribes(childNode, childHeading, '  ')
        .split('\n')
        .filter(line => line.trim() !== '') // Remove empty lines
        .join('\n');
      
      testFileContent += nestedContent;
    }
    
    // Add tests at the root level if any
    if (testHierarchy['PromptTrail ðŸš€'].tests.length > 0) {
      for (const block of testHierarchy['PromptTrail ðŸš€'].tests) {
        testFileContent += `  it('${block.test.description.replace(/'/g, "\\'")}', async () => {\n`;
        testFileContent += `    // Code from README.md\n`;
        testFileContent += `    // Test based on code from README.md\n`;
        
        // Add the test code with proper indentation
        const indentedTestCode = block.test.code
          .split('\n')
          .map(line => `    ${line}`)
          .join('\n');
        
        testFileContent += `${indentedTestCode}\n`;
        testFileContent += `  });\n\n`;
      }
    }
  }
  
  // Close the root describe block
  testFileContent += `});\n`;
  
  return testFileContent;
}

// Main function
async function main() {
  try {
    console.log('Reading README.md...');
    const readmeContent = fs.readFileSync(README_PATH, 'utf8');
    
    console.log('Extracting code blocks...');
    const codeBlocks = extractCodeBlocks(readmeContent);
    console.log(`Found ${codeBlocks.length} code blocks`);
    
    console.log('Extracting test comments...');
    const codeBlocksWithTests = extractTestComments(readmeContent, codeBlocks);
    console.log(`Found ${codeBlocksWithTests.length} code blocks with tests`);
    
    console.log('Extracting headings...');
    const headings = extractHeadings(readmeContent);
    console.log(`Found ${headings.length} headings`);
    
    console.log('Generating test file...');
    const testFileContent = generateTestFile(codeBlocksWithTests);
    
    console.log(`Writing test file to ${TEST_OUTPUT_PATH}...`);
    fs.writeFileSync(TEST_OUTPUT_PATH, testFileContent);
    
    console.log('Done!');
  } catch (error) {
    console.error('Error generating tests:', error);
    process.exit(1);
  }
}

main();
